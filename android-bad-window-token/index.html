<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/luffy.img?v=5.1.3"><link rel="mask-icon" href="/images/luffy.img?v=5.1.3" color="#222"><meta name="keywords" content="Android,BugFix,Framework,"><meta name="description" content="在我们的Bugly上一直有一个排名较高的崩溃android.view.WindowManager$BadTokenException，堆栈是这样的：12345678910111213141516android.view.WindowManager$BadTokenException Unable to add window -- token android.os.BinderProxy@43201"><meta name="keywords" content="Android,BugFix,Framework"><meta property="og:type" content="article"><meta property="og:title" content="一个诡异的BadTokenException"><meta property="og:url" content="http://blog.desmondyao.com/android-bad-window-token/index.html"><meta property="og:site_name" content="Desmond&#39;s Blog"><meta property="og:description" content="在我们的Bugly上一直有一个排名较高的崩溃android.view.WindowManager$BadTokenException，堆栈是这样的：12345678910111213141516android.view.WindowManager$BadTokenException Unable to add window -- token android.os.BinderProxy@43201"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.desmondyao.com/image/app-bad-token/1.png"><meta property="og:image" content="http://blog.desmondyao.com/image/mengbi.jpeg"><meta property="og:image" content="http://blog.desmondyao.com/image/app-bad-token/2.png"><meta property="og:image" content="http://blog.desmondyao.com/image/app-bad-token/3.png"><meta property="og:updated_time" content="2017-11-06T12:30:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="一个诡异的BadTokenException"><meta name="twitter:description" content="在我们的Bugly上一直有一个排名较高的崩溃android.view.WindowManager$BadTokenException，堆栈是这样的：12345678910111213141516android.view.WindowManager$BadTokenException Unable to add window -- token android.os.BinderProxy@43201"><meta name="twitter:image" content="http://blog.desmondyao.com/image/app-bad-token/1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.desmondyao.com/android-bad-window-token/"><title>一个诡异的BadTokenException | Desmond's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Desmond's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Focus on Java, Android, React Native.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.desmondyao.com/android-bad-window-token/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Desmond Yao"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Desmond's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">一个诡异的BadTokenException</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T20:30:53+08:00">2017-11-06</time></span></div></header><div class="post-body" itemprop="articleBody"><p>在我们的Bugly上一直有一个排名较高的崩溃<code>android.view.WindowManager$BadTokenException</code>，堆栈是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">android.view.WindowManager$BadTokenException Unable to add window -- token android.os.BinderProxy@432011d8 is not valid; is your activity running?</div><div class="line">  android.view.ViewRootImpl.setView(ViewRootImpl.java:594)</div><div class="line">  android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:269)</div><div class="line">  android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)</div><div class="line">  android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3099)</div><div class="line">  android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2350)</div><div class="line">  android.app.ActivityThread.access$1100(ActivityThread.java:139)</div><div class="line">  android.app.ActivityThread$H.handleMessage(ActivityThread.java:1256)</div><div class="line">  android.os.Handler.dispatchMessage(Handler.java:102)</div><div class="line">  android.os.Looper.loop(Looper.java:136)</div><div class="line">  android.app.ActivityThread.main(ActivityThread.java:5315)</div><div class="line">  java.lang.reflect.Method.invokeNative(Native Method)</div><div class="line">  java.lang.reflect.Method.invoke(Method.java:515)</div><div class="line">  com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:864)</div><div class="line">  com.android.internal.os.ZygoteInit.main(ZygoteInit.java:680)</div><div class="line">  dalvik.system.NativeStart.main(Native Method)</div></pre></td></tr></table></figure><p>这个是一个非常正常的Activity启动堆栈，一脸黑线。StackOverflow上一搜这个崩溃基本都是Dialog有关，那么这个是一个什么诡异的情况，我们研究了好几次，都没有什么结果。最近偶然发现了一点蛛丝马迹，顺藤摸瓜下去，终于找到了原因。</p><a id="more"></a><p>首先从源码来探究一下这个BadTokenException是怎么出来的吧：</p><h1 id="里面的”Token”是什么？"><a href="#里面的”Token”是什么？" class="headerlink" title="里面的”Token”是什么？"></a>里面的”Token”是什么？</h1><p>我们这个崩溃出现的地方全部都是在启动的第一个Activity中（即Launcher点击图标启动Activity），那就从这部分代码开始研究。</p><p>每一个<code>ActivityRecord</code>里面都有一个<code>appToken</code>变量，它是一个<code>Binder</code>对象，主要用于维持该Activity在AMS里与WindowManager之间的联系。它在<code>ActivityRecord</code>的构造函数中被初始化，通过调用<code>WindowManager.addAppToken</code>方法将该Token注册到WindowManagerService里面。</p><p>那么<code>ActivityRecord</code>是什么时候被初始化的呢？每一个Activity都在AMS里面有一个对应的ActivityRecord，在<code>startActivity</code>中的第一阶段就被初始化，并向WindowManagerService添加Token，我画了一张图来表示这个过程：</p><p><img src="/image/app-bad-token/1.png" alt="1"></p><p>在<code>WindowManagerService.addAppToken</code>函数中，它对传入的token进行了一层包装，为了理解后面的内容，这里简单介绍一下这个函数：</p><p>(代码做了大量精简，有兴趣的同学可以自己阅读）<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//WindowManagerService</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAppToken</span><span class="params">(<span class="keyword">int</span> addPos, IApplicationToken token, <span class="keyword">int</span> taskId, <span class="keyword">int</span> stackId,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedOrientation, <span class="keyword">boolean</span> fullscreen, <span class="keyword">boolean</span> showForAllUsers, <span class="keyword">int</span> userId,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> voiceInteraction, <span class="keyword">boolean</span> launchTaskBehind)</span> </span>&#123;</div><div class="line">        <span class="comment">// 一些七七八八的代码</span></div><div class="line"></div><div class="line">        AppWindowToken atoken = findAppWindowToken(token.asBinder());</div><div class="line">        <span class="keyword">if</span> (atoken != <span class="keyword">null</span>) &#123;</div><div class="line">            Slog.w(TAG, <span class="string">"Attempted to add existing app token: "</span> + token);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        atoken = <span class="keyword">new</span> AppWindowToken(<span class="keyword">this</span>, token, voiceInteraction);</div><div class="line">        <span class="comment">// 对Token的初始化和赋值操作</span></div><div class="line">        task.addAppToken(addPos, atoken);</div><div class="line"></div><div class="line">        mTokenMap.put(token.asBinder(), atoken); <span class="comment">//存入mTokenMap里</span></div><div class="line"></div><div class="line">        <span class="comment">//一些七七八八的代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>它根据传入的token新建了一个<code>AppWindowToken</code>对象，然后以传入的token为key，新建的对象为值放入了一个Map中。</p><p>我们再配合源码，可以看到先添加要启动的Activity的Token到WMS中，之后才会做下面几个操作：</p><ul><li>处理已Resumed的、正在Paused中的Activity，让他们进入Paused状态；</li><li>以<code>ActivityThread.main()</code>为入口启动进程，初始化Context和Application；</li><li>启动目标Activity。</li></ul><blockquote><p>可以参考部分<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external">罗升阳的Activity启动流程</a>，他分析的很好，可惜里面的Android版本有点老了。有兴趣的同学可以再看新的代码，我的分析是根据6.0的源码的。</p></blockquote><p>现在回头看看报错是在哪一步：handleResumeActivity。那必然是在上面添加Token之后的事情了，我们追一下看看发生了什么：</p><p>堆栈最后一步 ViewRootImpl.addView<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ViewRootImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//七七八八的代码</span></div><div class="line"></div><div class="line">        res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</div><div class="line">            getHostVisibility(), mDisplay.getDisplayId(),</div><div class="line">            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</div><div class="line">            mAttachInfo.mOutsets, mInputChannel);</div><div class="line"></div><div class="line">        <span class="comment">//七七八八的代码</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</div><div class="line">            mAttachInfo.mRootView = <span class="keyword">null</span>;</div><div class="line">            mAdded = <span class="keyword">false</span>;</div><div class="line">            mFallbackEventHandler.setView(<span class="keyword">null</span>);</div><div class="line">            unscheduleTraversals();</div><div class="line">            setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            <span class="keyword">switch</span> (res) &#123;</div><div class="line">                <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN:</div><div class="line">                <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</div><div class="line">                    <span class="comment">// 就是这里崩了</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(  </div><div class="line">                            <span class="string">"Unable to add window -- token "</span> + attrs.token</div><div class="line">                            + <span class="string">" is not valid; is your activity running?"</span>);</div></pre></td></tr></table></figure><p></p><p>这里的<code>mWindowSession</code>，它是一个Binder，具体的实现位于<code>Session.java</code>中。<code>ViewRootImpl</code>在初始化的时候会调用<code>WindowManagerGlobal.getWindowSession()</code>对它进行初始化，并保存在<code>WindowManagerGlobal</code>的静态变量<code>sWindowSession</code>中。之后Activity就能够通过这个Session通知WindowManager添加、删除View。</p><p>在<code>Session.addToDisplay</code>函数中我们可以看到它是直接透传给了<code>WindowManagerService</code>，并调用它的<code>addWindow</code>函数，我们看看它里面是怎么返回的。</p><ol><li><code>WindowManagerService.addWindow</code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WindowManagerService</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></div><div class="line"><span class="function"><span class="params">            WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></div><div class="line"><span class="function"><span class="params">            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></div><div class="line"><span class="function"><span class="params">            InputChannel outInputChannel)</span> </span>&#123;</div><div class="line"></div><div class="line">            WindowToken token = mTokenMap.get(attrs.token); <span class="comment">//从mTokenMap中拿传入token的对应AppWindowToken</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123; <span class="comment">//妈个鸡，没找到</span></div><div class="line">                <span class="keyword">if</span> (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123; </div><div class="line">                    Slog.w(TAG, <span class="string">"Attempted to add application window with unknown token "</span></div><div class="line">                          + attrs.token + <span class="string">".  Aborting."</span>);</div><div class="line">                    <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN; <span class="comment">//这里就返回了</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 剩下的代码都不重要了</span></div><div class="line">            &#125;</div></pre></td></tr></table></figure></li></ol><p>我们看到，这里就返回了<code>WindowManagerGlobal.ADD_BAD_APP_TOKEN</code>，然后<code>ViewRootImpl</code>那里就跑到了switch分支里面，报出崩溃。</p><p>好的，这是之前所有的研究成果，根本毫无头绪，怎么token突然没了？！这个bug就暂时搁置了。</p><h1 id="突然发现关键信息"><a href="#突然发现关键信息" class="headerlink" title="突然发现关键信息"></a>突然发现关键信息</h1><p>说到这里，不得不感谢一个<a href="http://stackoverflow.com/questions/5854290/why-does-resuming-an-activity-in-android-cause-badtokenexception" target="_blank" rel="external">StackOverflow</a>，它里面一个回答给了我提示：</p><blockquote><p>The change in my app that makes this crash possible is android:noHistory=”true” in Activity declaration of AndroidManifest.xml.</p></blockquote><p>没错，我们的启动Activity确实标记了<code>noHistory</code>。虽然后面经过研究，他猜测的原因错了，但是他提供了复现方法：在Application里面做一个特别耗时的行为，然后此时切回Launcher，等待一会，就会崩溃。</p><p>其实这个之前不是没有考虑过，我曾经试过在Application里面sleep 10秒，没有崩。然后这次我直接sleep 30秒，崩了。</p><p>那去除noHistory呢？没崩。</p><p><img src="/image/mengbi.jpeg" alt="mengbi"></p><p>官方文档说加了这个标志之后，不会被保留在Task中。这个标志是为什么加的其实我也不知道，一开始就有了。好的吧，那到底为什么加了它就崩了？这得研究一下吧。</p><p>其实光从这里，我也看不出什么，但是我在复现的时候，注意到了一个地方，sleep久的时候，也就是造成崩溃的时候，系统打出来的日志里面总会多出一行</p><blockquote><p>09-11 17:08:51.917 873-963/? W/ActivityManager: Activity destroy timeout for ActivityRecord{426e9e20 u0 com.desmond.testapplication/.MainActivity t21}</p></blockquote><p>每次只要有它，就一定会崩。那就有一个这个猜想：</p><blockquote><p>因为设置了noHistory为true的Activity在Stop时(按Home键触发）会强制触发destroy操作，但是此时Activity的主线程卡在了Application中无法顺利进行下面的操作，<strong>AMS判定Destroy超时，于是将它强制销毁了！</strong></p></blockquote><h1 id="追溯源码"><a href="#追溯源码" class="headerlink" title="追溯源码"></a>追溯源码</h1><p>首先我们看一下AMS对于设置了noHistory=true的Activity是怎么处理的，有一处关键的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ActivityStack.java</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != <span class="number">0</span></div><div class="line">            || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != <span class="number">0</span>) &#123; </div><div class="line">        <span class="keyword">if</span> (!r.finishing) &#123;</div><div class="line">            <span class="keyword">if</span> (!mService.isSleeping()) &#123; <span class="comment">// 设备没有进入Sleep</span></div><div class="line">                <span class="keyword">if</span> (requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="comment">//这里finish</span></div><div class="line">                        <span class="string">"stop-no-history"</span>, <span class="keyword">false</span>)) &#123;</div><div class="line">                    <span class="comment">// Activity was finished, no need to continue trying to schedule stop.</span></div><div class="line">                    adjustFocusedActivityLocked(r, <span class="string">"stopActivityFinished"</span>);</div><div class="line">                    r.resumeKeyDispatchingLocked();</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"Not finishing noHistory "</span> + r</div><div class="line">                        + <span class="string">" on stop because we're just sleeping"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>通过上面这段代码能够发现，对于noHistory的Activity，它确实会在stop的时候被AMS触发一个finish操作。那么这就能解释的通了，不过整个过程还是比较复杂，我将它缕一下。</p><p>先看看Destroy Timeout 是哪里发出来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ActivityStack.java</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">destroyActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> removeFromApp, String reason)</span> </span>&#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">if</span> (r.finishing &amp;&amp; !skipDestroy) &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Moving to DESTROYING: "</span> + r</div><div class="line">                    + <span class="string">" (destroy requested)"</span>);</div><div class="line">            r.state = ActivityState.DESTROYING;</div><div class="line">            Message msg = mHandler.obtainMessage(DESTROY_TIMEOUT_MSG, r);</div><div class="line">            mHandler.sendMessageDelayed(msg, DESTROY_TIMEOUT);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意这个<code>mHandler</code>是在AMS进程里的Handler，它使用的是<code>ActivityManagerService</code>里面成员变量<code>mHandler</code>的<code>Looper</code>，不会被Client-Side（即APP进程的操作所影响）。它在调用destroyActivityLocked的时候会先给Handler发一个延迟的TIMEOUT_MSG，如果client端顺利执行完了destroy，则会通知ActivityStack移除这个MSG，否则它就会被执行。</p><p>ActivityStack在收到这个消息以后会做一系列操作，可以参考这个图，我们可以看到最后它会把WindowManagerService中存的appToken给remove掉！</p><p><img src="/image/app-bad-token/2.png" alt="2"></p><p>然后注意，这个时候我们的Application还卡着呢！它现在卡在<code>ActivityThread.handleBindApplication</code>里面，换句话说，它的Handler卡在处理<code>BIND_APPLICATION</code>中了，无法处理之后的消息。<strong>自然所有的LAUNCH/RESUME/DESTROY全部都处理不了!</strong> 那么这个时候WindowToken会被Timeout移除，接下来它在处理排队中的消息时，处理到RESUME，走到最开始说的ActivityThread.handleResumeActivity=&gt;ViewRootImpl.addView，发现竟然找不到我的Token了！崩了。</p><p>没错，配合log，配合现象，这就是这个bug的唯一解释。</p><p>解释了后半部分，前半部分还不太清楚。DESTROY_TIMEOUT_MSG发送出来的呢？换句话说，<code>stopActivityLocked</code>是谁调用的呢？既然研究了就继续看一下。</p><p>按下Home键实际上是启动LauncherActivity，它是一个启动另外一个进程Activity的过程。我们可以通过按下Home键打出的<code>ActivityManager</code>的Log看出来：</p><blockquote><p>ActivityManager: START u0 {act=android.intent.action.MAIN cat=[android.intent.category.HOME]</p></blockquote><p>在LauncherActivity走到Resume过程的时候，<code>ActivityThread.handleResumeActivity</code>里面会调用<code>Looper.myQueue().addIdleHandler(new Idler());</code>添加一个<code>IdleHandler</code>，当Looper消息循环结束，进入空闲状态时会触发它的回调，象征着我现在客户端的主进程已经”Idle”了，随时待命。在这个IdleHandler里面调用<code>ActivityManagerService.activityIdle</code>函数。这里触发后续的操作，如图所示：</p><p><img src="/image/app-bad-token/3.png" alt="3"></p><p>ps：这也印证了A start B，肯定是B的resume走完，再走A的stop的。</p><h1 id="另外的尝试"><a href="#另外的尝试" class="headerlink" title="另外的尝试"></a>另外的尝试</h1><p>之前分析到，是在<code>handleResumeActivity</code>的时候才向WindowManagerService添加View的，那么如果是其他声明了noHistory=true的Activity在<code>onCreate</code>中做超长耗时，并按了Home键出去，会不会一样崩呢？</p><p>各位看官可以自己写一个Demo来验证一下。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>要说根本原因，肯定是不能再主线程里面做太多事情，特别是会在Application与Activity的onCreate阶段。如果说要把这个Bug解了，就把noHistory去掉，那stop不会强制触发finish，自然就没有DESTROY_TIMEOUT，AMS就不会强制干掉你的WindowToken了。</p><p>参考文章：</p><ul><li>Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析 by 罗升阳： <a href="http://blog.csdn.net/luoshengyang/article/details/8275938" target="_blank" rel="external">http://blog.csdn.net/luoshengyang/article/details/8275938</a></li><li>Android应用程序启动过程源代码分析 by 罗升阳： <a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external">http://blog.csdn.net/luoshengyang/article/details/6689748</a></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Android/" rel="tag"># Android</a> <a href="/tags/BugFix/" rel="tag"># BugFix</a> <a href="/tags/Framework/" rel="tag"># Framework</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/android-storage/" rel="next" title="Android存储挖坑记"><i class="fa fa-chevron-left"></i> Android存储挖坑记</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/fresco-4-async/" rel="prev" title="Fresco源码分析(4) - 异步加载数据">Fresco源码分析(4) - 异步加载数据 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Desmond Yao</p><p class="site-description motion-element" itemprop="description">Android developer.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#里面的”Token”是什么？"><span class="nav-number">1.</span> <span class="nav-text">里面的”Token”是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#突然发现关键信息"><span class="nav-number">2.</span> <span class="nav-text">突然发现关键信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#追溯源码"><span class="nav-number">3.</span> <span class="nav-text">追溯源码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#另外的尝试"><span class="nav-number">4.</span> <span class="nav-text">另外的尝试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解决办法"><span class="nav-number">5.</span> <span class="nav-text">解决办法</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Desmond Yao</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script></body></html>