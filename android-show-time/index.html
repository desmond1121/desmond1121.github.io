<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/luffy.img?v=5.1.3"><link rel="mask-icon" href="/images/luffy.img?v=5.1.3" color="#222"><meta name="keywords" content="Android,Framework,"><meta name="description" content="这两天我的包工头歪龙木·灵魂架构师·王半仙·Yrom给我派了一个活：统计App冷启动时间。这个任务看上去不难，但是要求统计出来的时间要准，要特别准。意思就是，我必须要按Activity绘制到屏幕上这个时间节点作为标杆，来进行我的统计工作。毕竟如果是因为视图处理不当而导致的measure/layout/draw耗时太久，这是不能忍的，需要及时统计到。虽然有点蛋疼，但是这个任务还算有意义，我就深挖一下"><meta name="keywords" content="Android,Framework"><meta property="og:type" content="article"><meta property="og:title" content="Activity到底是什么时候显示到屏幕上的呢？"><meta property="og:url" content="http://blog.desmondyao.com/android-show-time/index.html"><meta property="og:site_name" content="Desmond&#39;s Blog"><meta property="og:description" content="这两天我的包工头歪龙木·灵魂架构师·王半仙·Yrom给我派了一个活：统计App冷启动时间。这个任务看上去不难，但是要求统计出来的时间要准，要特别准。意思就是，我必须要按Activity绘制到屏幕上这个时间节点作为标杆，来进行我的统计工作。毕竟如果是因为视图处理不当而导致的measure/layout/draw耗时太久，这是不能忍的，需要及时统计到。虽然有点蛋疼，但是这个任务还算有意义，我就深挖一下"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.desmondyao.com/image/activity-show-time/1.jpg"><meta property="og:image" content="http://blog.desmondyao.com/image/activity-show-time/2.jpg"><meta property="og:image" content="http://blog.desmondyao.com/image/activity-show-time/3.jpg"><meta property="og:image" content="http://blog.desmondyao.com/image/activity-show-time/4.jpg"><meta property="og:updated_time" content="2017-11-06T12:30:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Activity到底是什么时候显示到屏幕上的呢？"><meta name="twitter:description" content="这两天我的包工头歪龙木·灵魂架构师·王半仙·Yrom给我派了一个活：统计App冷启动时间。这个任务看上去不难，但是要求统计出来的时间要准，要特别准。意思就是，我必须要按Activity绘制到屏幕上这个时间节点作为标杆，来进行我的统计工作。毕竟如果是因为视图处理不当而导致的measure/layout/draw耗时太久，这是不能忍的，需要及时统计到。虽然有点蛋疼，但是这个任务还算有意义，我就深挖一下"><meta name="twitter:image" content="http://blog.desmondyao.com/image/activity-show-time/1.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.desmondyao.com/android-show-time/"><title>Activity到底是什么时候显示到屏幕上的呢？ | Desmond's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Desmond's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Focus on Java, Android, React Native.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.desmondyao.com/android-show-time/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Desmond Yao"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Desmond's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Activity到底是什么时候显示到屏幕上的呢？</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-22T20:56:23+08:00">2016-09-22</time></span></div></header><div class="post-body" itemprop="articleBody"><p>这两天我的包工头<a href="https://yrom.net" target="_blank" rel="external">歪龙木·灵魂架构师·王半仙·Yrom</a>给我派了一个活：统计App冷启动时间。这个任务看上去不难，但是要求统计出来的时间要<strong>准</strong>，要<strong>特别准</strong>。</p><p>意思就是，我必须要按Activity绘制到屏幕上这个时间节点作为标杆，来进行我的统计工作。毕竟如果是因为视图处理不当而导致的measure/layout/draw耗时太久，这是不能忍的，需要及时统计到。虽然有点蛋疼，但是这个任务还算有意义，我就深挖一下，把过程分享出来。</p><a id="more"></a><blockquote><p>注：本文所涉及源码部分的sdk level为21</p></blockquote><h2 id="onResume真的已经显示了吗？"><a href="#onResume真的已经显示了吗？" class="headerlink" title="onResume真的已经显示了吗？"></a>onResume真的已经显示了吗？</h2><p>如果你看过官方文档中的Activity生命指引，你会发现它说的是</p><blockquote><p>Activity在onResume生命周期中已经是可见状态。</p></blockquote><p>那么我们就去这个onResume中看一看。现在我在Activty的onCreate第一行（<code>super.onCreate</code>之前）记录一个时间点，onResume的最后一行(<code>super.onResume</code>之后)记录一个时间点，将两者的差值记录下来。</p><p>打出来的Log是：<strong>I/MainActivity: onCreate -&gt; onResume : 70</strong>。 即这个过程花费了70ms。那真的是只用了70ms我的Activity就已经完全显示了吗？我们来看两个官方的衡量点：</p><ul><li>通过adb shell的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ adb shell am start -W com.desmond.demo/.MainActivity</div><div class="line"></div><div class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.desmond.demo/.MainActivity &#125;</div><div class="line">Status: ok</div><div class="line">Activity: com.desmond.demo/.MainActivity</div><div class="line">ThisTime: 314</div><div class="line">TotalTime: 314</div><div class="line">WaitTime: 314</div><div class="line">Complete</div></pre></td></tr></table></figure><ul><li>启动Activity时的可以看Tag = ActivityManager打出来的Log：</li></ul><blockquote><p>I/ActivityManager: Displayed com.desmond.testapplication/.MainActivity: +314ms</p></blockquote><p>这两个时间是一样的，我们看哪个都行。这个314ms的启动过程和上面的70ms<strong>是同一次启动过程打出来的日志</strong>，那么问题来了，怎么会和我打出来的Log时间相差这么大？我们先看看系统打出来的时间到底是什么时间。</p><p>打出这段log的代码在<code>ActivityRecord</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ActivityRecord</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportLaunchTimeLocked</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> curTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ActivityStack stack = task.stack;</div><div class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> thisTime = curTime - displayStartTime;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> totalTime = stack.mLaunchStartTime != <span class="number">0</span></div><div class="line">            ? (curTime - stack.mLaunchStartTime) : thisTime;</div><div class="line">    <span class="keyword">if</span> (SHOW_ACTIVITY_START_TIME) &#123;</div><div class="line">        <span class="comment">// ...其他代码</span></div><div class="line">        StringBuilder sb = service.mStringBuilder;</div><div class="line">        sb.setLength(<span class="number">0</span>);</div><div class="line">        sb.append(<span class="string">"Displayed "</span>);</div><div class="line">        sb.append(shortComponentName);</div><div class="line">        sb.append(<span class="string">": "</span>);</div><div class="line">        TimeUtils.formatDuration(thisTime, sb);</div><div class="line">        <span class="keyword">if</span> (thisTime != totalTime) &#123;</div><div class="line">            sb.append(<span class="string">" (total "</span>);</div><div class="line">            TimeUtils.formatDuration(totalTime, sb);</div><div class="line">            sb.append(<span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line">        Log.i(TAG, sb.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...其他代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它的调用时机我们后面再讨论，首先看一下它打出了什么。这个函数中将<code>totalTime</code>作为Displayed时间打了出来，值为<code>当前时间 - stack.mLaunchStartTime</code>。那这个mLaunchStartTime是什么时候被记录的呢？查了一下调用发现在<code>ActivityStackSupervisor.startSpecificActivityLocked</code>会调用<code>stack.setLaunchTime(r)</code>去设置这个时间。</p><p>那么我们可以得出第一个结论：</p><blockquote><p>结论1： <strong>系统打出来的时间包含了进程启动的时间。</strong></p></blockquote><p>因为进程启动都是在<code>ActivityStackSupervisor.startSpecificActivityLocked()</code>中进行的，以ActivityThread.main为入口启动一个新进程。如果对于这里不明白，可以参考一下老罗的<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external">Android应用程序启动过程源代码分析</a>。</p><p>但是进程启动这么耗时？我的test activiy也没有自定义Application，更别提什么耗时操作了。我来实践一下<strong>热启动</strong>，App退出，但是不杀进程，再对比一下我打的log和系统log的时间区别。</p><p>我：I/MainActivity: onCrete -&gt; onResume : 37<br>系统： I/ActivityManager: Displayed com.desmond.testapplication/.MainActivity: +103ms</p><p><strong>依然差了很多！</strong></p><p>看来我们需要研究一下Activity的onResume过程及系统上报Displayed的时机了。</p><h2 id="深入探究onResume过程"><a href="#深入探究onResume过程" class="headerlink" title="深入探究onResume过程"></a>深入探究onResume过程</h2><p>我先对AMS触发Activity的onResume这个过程画了一张图：</p><p><img src="/image/activity-show-time/1.jpg" alt="1"></p><p>在ActivityManagerService(AMS)告知Activity要resume时，它通过调用<code>ApplicationThread.scheduleResumeActivity</code>给<code>ActivityThread.H</code>（一个Handler）发送消息<code>RESUME_ACTIVITY</code>，然后H开始处理消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> RESUME_ACTIVITY:</div><div class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityResume"</span>);</div><div class="line">    handleResumeActivity((IBinder) msg.obj, <span class="keyword">true</span>, msg.arg1 != <span class="number">0</span>, <span class="keyword">true</span>);</div><div class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure><p>在这个<code>handleResumeActivity</code>中就处理了所有的Resume逻辑，我们进去一探究竟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ActivityThread.java</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</div><div class="line">    <span class="comment">// 一些其他代码</span></div><div class="line"></div><div class="line">    <span class="comment">// 这步onResume</span></div><div class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">final</span> Activity a = r.activity;</div><div class="line"></div><div class="line">        <span class="comment">// 一些其他代码</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class="line">            r.window = r.activity.getWindow();</div><div class="line">            View decor = r.window.getDecorView();</div><div class="line">            decor.setVisibility(View.INVISIBLE);</div><div class="line">            ViewManager wm = a.getWindowManager();</div><div class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</div><div class="line">            a.mDecor = decor;</div><div class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class="line">            l.softInputMode |= forwardBit;</div><div class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</div><div class="line">                a.mWindowAdded = <span class="keyword">true</span>;</div><div class="line">                wm.addView(decor, l); <span class="comment">//这步很关键</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Activity.onResume() 这一步就是在<code>performResumeActivity</code>里面调用的，有兴趣的同学可以去看看，里面代码很简单。</p><p>为什么说<code>wm.addView</code>这一步很关键？真正对Activity的视图进行计算、绘制、flush到window上是<code>wm.addWindow</code>这一步做的，这里面代码比较多，我直接画张图看清晰一点：</p><p><img src="/image/activity-show-time/2.jpg" alt="activity-show-time-2"></p><p>这张图的代码就不放了，关键的类和方法都在里面，有兴趣的同学可以自行翻阅。有几个注意的点：</p><ol><li><code>Activity#getWindowManager()</code>拿到的是Activity的成员变量<code>mWindowManager</code>，它是一个<code>WindowManagerIpml</code>实例，在<code>Activity.attach</code>内被赋值。所以我们在第一步直接就跳转到了<code>WindowManagerImpl.addView()</code></li><li><code>ViewRootImpl</code>在requestLayout的时候将一个Runnable交由<a href="https://developer.android.com/reference/android/view/Choreographer.html" target="_blank" rel="external">Choreographer</a>去调度，让它能够在下一个绘制帧时执行它。这个Runnable内只有一条语句，就是执行<code>doTraversal</code>，主要的内容在其中执行的<code>performTraversal</code>中，这个函数非常非常长，做的事情大致就是从顶至下的measure/layout/draw，通知<code>ViewTreeObserver</code>的各类Listener也大部分都是在这一步中完成的。</li></ol><p>这时候我们回头看之前<code>ActivityThread.handleResumeActivity</code>的代码：<strong>Activity的onResume在wm.addView之前！</strong>。因为View的计算、绘制等都在wm.addView之后执行，那我们可以得出第二个结论：</p><blockquote><p>结论2： <strong>在onResume的时候是肯定统计不到View的measure/layout/draw时间的。</strong></p></blockquote><p>这时候我们要搞清楚的是，上面系统的Log是在哪一步调用的，它是否包含了View的measure/layout/draw的时间？这个过程可是一顿好找，大概是如下图所示流程：</p><p><img src="/image/activity-show-time/3.jpg" alt="3"></p><p>5-6步之间被我<strong>精简</strong>了一小部分内容，我来简单解释一下这个过程：</p><ol><li>ViewRootImpl在<code>performTraversals()</code>的最后会调用<code>performDraw()</code>来将内容绘制到Surface上，最后一步它会执行<code>mWindowSession.finishDrawing</code>。这个<code>mWindowSession</code>是一个Session对象，它维持着ViewRootImpl与WindowManagerService(WMS)之间的联系。（ViewRootImpl与WMS通信部分可以参考老罗的<a href="http://blog.csdn.net/luoshengyang/article/details/8275938" target="_blank" rel="external">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>)</li><li>在这之后WMS通过Handler来调度绘制Surface的任务，它给自己内部类H发送了一个<code>DO_TRAVERSAL</code>消息。收到消息之后它就会执行<code>performLayoutAndPlaceSurfacesLocked</code>函数，之后有一系列的链式调用由于方法名字太长并且于本文没有太多用处，在我的图里被省略了。最后它会走到<code>performLayoutAndPlaceSurfacesLockedInner</code>，这里面会将Surface绘制到屏幕上，并调用<code>handleAppTransitionReadyLocked</code>，并如图所示继续向后调用。</li><li>ActivityRecord.Token是一个Binder对象，它活在ActivityManagerService进程中，用于AMS与WMS之间的通信。相对应的，AppWindowToken活在WindowManagerService进程中。每一个ActivityRecord.Token都对应一个AppWindowToken。它们的连接建立可以参考上面说到的老罗文章，以及我的另一篇文章：<a href="http://blog.desmondyao.com/android-bad-window-token/">一个诡异的BadTokenException</a>。</li></ol><p>那我们可以确定的是，在看到系统这条日志时，View的计算、绘制已经完成，并且Surface也被绘制到屏幕上。这样我们可以得出第三个结论：</p><blockquote><p>结论3： <strong>系统打出来的日志时Activity已经被完全展示到了屏幕上。</strong></p></blockquote><h2 id="View绘制结束的回调时机"><a href="#View绘制结束的回调时机" class="headerlink" title="View绘制结束的回调时机"></a>View绘制结束的回调时机</h2><p>得出了结论，那我们要怎么知道什么时候View绘制结束呢？这里就仁者见仁，智者见智了。</p><p>首先可以确认的是，所有ViewTreeObserver里面的Listener都是不够准确的。为什么呢？它们里面能统计到的最迟就是<code>OnDrawListener</code>，我们可以在<code>ViewRootImpl#draw()</code>函数中看到，它是在真正draw这一步之前调用的，也就是说它没有统计到draw的时间。</p><p>我提供一个思路，能够准确获取到包括View的measure/layout/draw过程的时间。那就是在<code>onResume</code>中添加一个<code>IdleHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onResume();</div><div class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</div><div class="line">            Log.i(TAG, <span class="string">"onCreate -&gt; idle : "</span> + (SystemClock.uptimeMillis() - time));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个IdleHandler是什么？它会在Looper的消息队列处理完当前阻塞的消息（即Idle中，等待获取下一条消息）时被调用。我这里直接指定了主线程的消息队列，那我在<code>onResume</code>中给它加入一个IdleHandler，它会什么时候调用呢，我们回顾一下Activity的onResume-&gt;ViewRoot的traversal这个过程，我做了一些修改：</p><p><img src="/image/activity-show-time/4.jpg" alt="4"></p><p>这里有一个需要注意的地方：</p><p>ViewRootImpl在向Choreographer发送调度消息时，特地向主线程的Looper消息循环发送了一个“障碍消息”。利用<code>MessageQueue#postSyncBarrier</code>可以做到这一点，当出现了这一个障碍消息的时候，消息循环就暂时无法处理后续排入消息。有兴趣的同学可以自行研究这个过程。</p><p>Choreographer通过直接在native操作主进程的MessageQueue来排入消息，从而它的执行会无视我们加入的“障碍消息”。（这部分代码就不深入了，可以参考老罗的<a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="external">Android应用程序消息处理机制（Looper、Handler）分析</a>）。即<code>ViewRootImpl#doTraversal</code>这个函数也是在一次消息处理中发生的。它此时移除了MessageQueue里面的障碍消息，并且执行performTraversals。</p><p>需要注意的是：<strong>这整个过程都是在主线程的消息循环中发生的。</strong>这个过程可以描述为如下几步：</p><ol><li>ActivityThread.H在处理<code>RESUME_ACTIVITY</code>消息时调用的<code>handleResumeActivity</code>会触发<code>Activity#onResume</code>与<code>ViewRootImpl#doTraversal</code>。</li><li><code>ViewRootImpl#doTraversal</code>向主进程Looper发送了一个“障碍消息”，使主进程Looper无法继续处理后续消息。</li><li>Choreographer通过native向主进程Looper排入消息，移除“障碍消息”，并执行<code>ViewRootImpl#doTraversal</code>。</li></ol><p>所以如果我们在onResume中向主进程添加入一个IdleHandler，它是必然会在这三步都走完，主进程Looper的MessageQueue才可能触发Idle状态，并触发IdleHandler回调。</p><p>我们可以实验一下：在添加入的IdleHandler内打点，计算与onCreate第一行打点时间之差，最后打出来的Log：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MainActivity: onCrete -&gt; onResume : 12</div><div class="line">MainActivity: onCrete -&gt; onPreDraw : 138</div><div class="line">MainActivity: onCrete -&gt; onPreDraw : 147</div><div class="line">MainActivity: onCrete -&gt; idleHandler : 166</div><div class="line">ActivityManager: Displayed com.desmond.testapplication/.MainActivity: +192ms</div></pre></td></tr></table></figure><p>虽然还是离ActivityManager打出来的差了一点，但是这也是有理由的。我们看上面的WMS绘制Surface那一步，是通过Handler发送异步消息完成的，这里统计不到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然没有完全贴近系统打出来的日志，但是通过IdleHandler的方式已经能统计到我想要的内容了（由Activity的onCreate第一步到整个界面显示）。</p><p>老罗的博客和AOSP源码都是很棒的参考资料，建议多看看Handler/Looper的消息循环机制、AMS/WMS/主进程之间的交互，才能比较好的理解这个过程。</p><p>参考文章：</p><ul><li><a href="http://hukai.me/android-performance-patterns-season-6/" target="_blank" rel="external">Android性能优化典范(第6季)</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="external">Android应用程序消息处理机制（Looper、Handler）分析</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/8275938" target="_blank" rel="external">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Android/" rel="tag"># Android</a> <a href="/tags/Framework/" rel="tag"># Framework</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/android-test/" rel="next" title="Android测试驱动开发(TDD)"><i class="fa fa-chevron-left"></i> Android测试驱动开发(TDD)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/super-activity-test/" rel="prev" title="分享一个对所有Activity做单元测试的思路">分享一个对所有Activity做单元测试的思路 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Desmond Yao</p><p class="site-description motion-element" itemprop="description">Android developer.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/desmond1121" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://weibo.com/u/1901104743" target="_blank" title="Weibo"><i class="fa fa-fw fa-globe"></i>Weibo</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://kaedea.com/" title="Kaedea" target="_blank">Kaedea</a></li><li class="links-of-blogroll-item"><a href="http://yrom.net/" title="Yrom" target="_blank">Yrom</a></li><li class="links-of-blogroll-item"><a href="http://blog.zhaiyifan.cn/" title="MarkZhai" target="_blank">MarkZhai</a></li><li class="links-of-blogroll-item"><a href="http://abner-nimengbo.cn/" title="泥阿布" target="_blank">泥阿布</a></li><li class="links-of-blogroll-item"><a href="https://xiequan.info" title="谢权" target="_blank">谢权</a></li><li class="links-of-blogroll-item"><a href="http://rarnu.com/" title="何老师" target="_blank">何老师</a></li><li class="links-of-blogroll-item"><a href="http://fucknmb.com/" title="区长" target="_blank">区长</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#onResume真的已经显示了吗？"><span class="nav-number">1.</span> <span class="nav-text">onResume真的已经显示了吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入探究onResume过程"><span class="nav-number">2.</span> <span class="nav-text">深入探究onResume过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View绘制结束的回调时机"><span class="nav-number">3.</span> <span class="nav-text">View绘制结束的回调时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Desmond Yao</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script></body></html>