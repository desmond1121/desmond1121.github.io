<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/luffy.img?v=5.1.3"><link rel="mask-icon" href="/images/luffy.img?v=5.1.3" color="#222"><meta name="keywords" content="源码解析,Fresco,"><meta name="description" content="Fresco的源码中，DraweeView的介绍简洁明了：我就是把DraweeHierarchy显示到屏幕上的家伙。那我们来分析一下相关代码，看看它的逻辑是什么样的。1 时序图首先可以用以下这个图初步理解SimpleDraweeView在调用了setUri(Uri uri)之后的流程："><meta name="keywords" content="源码解析,Fresco"><meta property="og:type" content="article"><meta property="og:title" content="Fresco源码分析(3) - DraweeView显示图层树"><meta property="og:url" content="http://blog.desmondyao.com/fresco-3-draweeview/index.html"><meta property="og:site_name" content="Desmond&#39;s Blog"><meta property="og:description" content="Fresco的源码中，DraweeView的介绍简洁明了：我就是把DraweeHierarchy显示到屏幕上的家伙。那我们来分析一下相关代码，看看它的逻辑是什么样的。1 时序图首先可以用以下这个图初步理解SimpleDraweeView在调用了setUri(Uri uri)之后的流程："><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.desmondyao.com/image/fresco/sequence_diagram_setUriSeq1.PNG"><meta property="og:image" content="http://blog.desmondyao.com/image/fresco/class_diagram_draweeview.PNG"><meta property="og:updated_time" content="2017-11-06T12:30:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Fresco源码分析(3) - DraweeView显示图层树"><meta name="twitter:description" content="Fresco的源码中，DraweeView的介绍简洁明了：我就是把DraweeHierarchy显示到屏幕上的家伙。那我们来分析一下相关代码，看看它的逻辑是什么样的。1 时序图首先可以用以下这个图初步理解SimpleDraweeView在调用了setUri(Uri uri)之后的流程："><meta name="twitter:image" content="http://blog.desmondyao.com/image/fresco/sequence_diagram_setUriSeq1.PNG"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.desmondyao.com/fresco-3-draweeview/"><title>Fresco源码分析(3) - DraweeView显示图层树 | Desmond's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Desmond's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Focus on Java, Android, React Native.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.desmondyao.com/fresco-3-draweeview/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Desmond Yao"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Desmond's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Fresco源码分析(3) - DraweeView显示图层树</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T20:30:53+08:00">2017-11-06</time></span></div></header><div class="post-body" itemprop="articleBody"><p>Fresco的源码中，DraweeView的介绍简洁明了：我就是把DraweeHierarchy显示到屏幕上的家伙。那我们来分析一下相关代码，看看它的逻辑是什么样的。</p><h2 id="1-时序图"><a href="#1-时序图" class="headerlink" title="1 时序图"></a>1 时序图</h2><p>首先可以用以下这个图初步理解SimpleDraweeView在调用了<code>setUri(Uri uri)</code>之后的流程：</p><p><img src="/image/fresco/sequence_diagram_setUriSeq1.PNG" alt="DraweeView"></p><a id="more"></a><p>可以将这张图描述为以下信息：</p><ul><li>DraweeView直接显示DraweeHierarchy；</li><li>DraweeController根据Uri获取数据源<code>DataSource</code>，并绑定数据订阅者<code>DataSubscriber</code>；</li><li>当<code>DataSource</code>可以更新数据时通知<code>DataSubscriber</code>更新DraweeHierarchy。（在<a href="https://blog.desmondyao.com/2016/04/01/fresco-4-async.md">Fresco源码分析(4) - 异步加载数据</a>中分析）</li></ul><h2 id="2-基类DraweeView"><a href="#2-基类DraweeView" class="headerlink" title="2 基类DraweeView"></a>2 基类DraweeView</h2><p><code>DraweeView&lt;DH extends DraweeHierarchy&gt;</code>是Fresco视图中的基类，使用的泛型必须是<code>DraweeHierarchy</code>，它继承了<code>ImageView</code>。</p><p><code>DraweeView</code>内部的函数不多，<strong>它们全部都是通过DraweeHolder的相应函数实现的。</strong>主要有以下这几个：</p><ul><li><code>void init(Context context)</code> 初始化<code>DraweeHolder</code>；</li><li><code>void setHierarchy(DH hierarchy)</code> 设置图层树，会调用 <code>super.setImageDrawable(mDraweeHolder.getTopLevelDrawable())</code>将图层树显示出来；</li><li><code>void setController(@Nullable DraweeController draweeController)</code> 设置<code>DraweeController</code>，像<code>setHierarchy</code>一样同样也会显示图层树；</li><li><code>Drawable getTopLevelDrawable()</code> 获取通过包装好的图层树(见<a href="https://blog.desmondyao.com/2016/04/01/fresco-2-hierarchy.md">DraweeHierarchy构建图层</a>)；</li><li><code>View</code>中的<code>onAttachedToWindow()</code>、 <code>onDetachedFromWindow()</code>、 <code>onStartTemporaryDetach()</code>、 <code>onFinishTemporaryDetach()</code> 四个回调函数，提供当视图被绑定/解绑到指定布局上时的回调函数，它们会触发<code>DraweeHolder</code>的<code>onDetach()</code>或<code>onAttach()</code>；</li><li><code>void onTouchEvent(MotionEvent event)</code> 提供触屏反应。</li></ul><p>在使用它之前要注意官方的API注释中有这么一段话：</p><blockquote><p><em>你只能在将DraweeView仅仅当做ImageView来使用时才调用<code>setImageXXX</code>函数。</em></p></blockquote><p>要记住它：无论什么形式的<code>DraweeView</code>，目标图片的设置最终都是通过<code>DraweeController</code>。我们会在下一章中介绍<code>DraweeController</code>，它是连接<code>DraweeHierarchy</code>与<code>Image Pipeline</code>的桥梁。虽然<code>setHierarchy</code>与<code>setController</code>都会显示出图层树，但是实际上<strong><code>setHierarchy</code>在显示图片的时候只是把<code>DraweeView</code>当做普通的<code>ImageView</code>使用</strong>，要使用Fresco的缓存、加载机制，必须使用<code>DraweeController</code>。</p><p>不过所幸Fresco实现了<code>SimpleDraweeVew</code>帮我们来处理这些繁琐的过程，它封装了<code>Controller</code>的使用。</p><h3 id="2-1-DraweeHolder"><a href="#2-1-DraweeHolder" class="headerlink" title="2.1 DraweeHolder"></a>2.1 DraweeHolder</h3><p><code>DraweeHolder</code>充斥在<code>DraweeView</code>的各个位置，每个<code>DraweeView</code>的函数都是由它的对应函数执行的。它随着<code>DraweeView</code>的产生而初始化。在深入了解视图绘制之前，我们有必要了解它是做什么的。</p><p><code>DraweeHolder</code>是用来维持<code>DraweeHierarchy</code>和<code>DraweeController</code>之间的沟通的。通过<code>create( DH hierarchy, Context context)</code>来创建实例，<code>DraweeHierarchy</code>通过第一个参数赋值，其中第二个参数用于<code>registerWithContext(Context)</code>（该函数暂时没有完善好）。</p><p>它有几个主要使用的函数：</p><ul><li><code>void setHierarchy(DH hierarchy)</code> 在<code>DraweeView.setHierarchy</code>中被调用，将DraweeHierarchy传给持有的DraweeController；</li><li><code>void setController(DraweeController draweeController)</code> 在<code>DraweeeView.setController</code>中被调用无条件解绑旧的Controller（如果存在的话），并将旧DraweeController的DraweeHierarchy设置为null，并调用<code>DraweeController.onDetach()</code>将它变为解除绑定状态；将持有的DraweeHierarchy（如果有的话）赋给新传入的DraweeController并调用<code>DraweeController.onAttach()</code>让它变为绑定状态。（<strong>更换DraweeController确是一个非常耗时的过程，应该尽量避免为视图指定新的DraweeController，参考<a href="http://fresco-cn.org/docs/using-controllerbuilder.html#draweecontroller" target="_blank" rel="external">官方文档</a>）</strong></li><li><code>void attachController()</code> 若所属的<code>DraweeView</code>未绑定<code>DraweeController</code>，<code>DraweeController</code>成员变量不为空并且已经设置过图层树之后，调用该成员变量的<code>onAttach</code>方法；</li><li><code>void detachController()</code> 若所属的<code>DraweeView</code>已绑定<code>DraweeController</code>，<code>DraweeController</code>成员变量不为空，调用该成员变量的<code>onDetach</code>方法；</li><li><code>void attachOrDetachController()</code> 当已绑定<code>DraweeController</code>并且所属的<code>DraweeView</code>可见时，调用<code>attachController</code>；否则调用<code>detachController</code>。</li></ul><p>特别地，<code>DraweeHolder</code>继承了<code>VisibilityCallback</code>，为<code>DraweeHierarchy.RootDrawable</code>提供回调：当图层的Visibility属性改变的时候对<code>DraweeController</code>调用<code>attachOrDetachController</code>操作，当图层不可见时释放资源。</p><h3 id="2-2-GenericDraweeView"><a href="#2-2-GenericDraweeView" class="headerlink" title="2.2 GenericDraweeView"></a>2.2 GenericDraweeView</h3><p><code>GenericDraweeView</code>就是使用<code>GenericDraweeHierarchy</code>图层树的视图，它承担了所有的xml属性交互工作。</p><p><em>实际上在图层树上目前Fresco也只实现了一个<code>GenericDraweeHierarchy</code>，使用泛型是为了后续的开发便利。</em></p><p>它会在初始化的时候调用<code>inflateHierarchy(Context context, AttributeSet attrs)</code>函数，从xml的中获取如下几个属性（如果存在的话）：</p><ul><li><code>fadeDuation</code> 渐隐/渐显动画时间；</li><li><code>aspectRatio</code> 图片长宽比例，参考<a href="http://fresco-cn.org/docs/using-drawees-xml.html#wrap-content" target="_blank" rel="external">官方文档</a>；</li><li><code>`XXXImage</code>/<code>XXXImageScaleType</code> 各图层要显示的Drawable（除了目标显示图层）及它们的<code>ScaleType</code>；</li><li><code>RoundingParams</code>中的参数</li></ul><p>在它的Measure过程中，会依次判断是否高度、宽度属性中有<code>wrap_content</code>，会将先判断到的属性更正为实际长度。<strong>但是Fresco并不支持使用wrap_content。</strong>如果你非要使用，只能在width/height中使用一侧，然后搭配<code>aspectRatio</code>使用。</p><p><strong>在GenericDraweeView获取完xml属性之后，它会通过<code>GenericDraweeHierarchyBuilder.build</code>创造一个与之对应的GenericDraweeHierarchy作为默认使用的图层树，并调用<code>setHierarchy</code>方法将其传递给<code>DraweeHolder</code>并显示出来。</strong></p><h3 id="2-3-SimpleDraweeView"><a href="#2-3-SimpleDraweeView" class="headerlink" title="2.3 SimpleDraweeView"></a>2.3 SimpleDraweeView</h3><p>在SimpleDraweeView中的函数就更少了，可以明确的说，它就只是将GenericDraweeHierarchy显示到UI界面上的空间而已。它比GenericDraweeView多出来的功能就是<strong>它内部提供了最简单的DraweeController实现</strong>。它有两个函数比较需要关注：</p><ul><li><p><code>initialize</code>函数，这个函数会在<code>Fresco.initialize</code>中调用，目的就是初始化DraweeControllerBuilder，用于构建DraweeController。</p></li><li><p><code>setImageURI</code> 这个函数我们会经常调用，因此有必要看看它的实现和普通ImageView的<code>setImageXXX</code>方法有什么区别：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageURI</span><span class="params">(Uri uri, @Nullable Object callerContext)</span> </span>&#123;</div><div class="line">  DraweeController controller = mSimpleDraweeControllerBuilder</div><div class="line">      .setCallerContext(callerContext)</div><div class="line">      .setUri(uri)</div><div class="line">      .setOldController(getController())</div><div class="line">      .build();</div><div class="line">  setController(controller);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而<code>setController</code>会调用<code>DraweeHolder.setController</code>，将图层树的控制权交给DraweeController，并显示出图层树。</p><h2 id="3-DraweeController"><a href="#3-DraweeController" class="headerlink" title="3 DraweeController"></a>3 DraweeController</h2><p>DraweeController是一个将Fresco中负责数据加载的组件组合起来并将信息反映到DraweeHierarchy的组件。它通过建造者模式初始化，基类<code>AbstractDraweeControllerBuilder</code>使用了四个泛型：（括号中为<code>PipelineDraweeControllerBuilder</code>所使用的类型）</p><ul><li>BUILDER 建造者类型(AbstractDraweeControllerBuilder)</li><li>REQUEST 图像请求类型(ImageRequest)</li><li>IMAGE 图像类型(CloseableReference<closeableimage>)</closeableimage></li><li>INFO 图像信息类型(ImageInfo)</li></ul><p>在<code>.build()</code>中会初始化DraweeController。下面我们会先介绍几个关键概念，然后介绍DraweeController的初始化过程。</p><h3 id="3-1-ImageRequest"><a href="#3-1-ImageRequest" class="headerlink" title="3.1 ImageRequest"></a>3.1 ImageRequest</h3><p><code>ImageRequest</code>存储着Image Pipeline处理被请求图片所需要的有用信息(Uri、是否渐进式图片、是否返回缩略图、缩放、是否自动旋转等)。</p><p><strong>ImagePipeline仅仅用来装信息，而且一经初始化后就只能获取内容，无法改变内容（即Immutable）。</strong> 初始化ImageRequest只能通过<code>ImageRequest.fromUri(Uri uri)</code>或<code>ImageRequestBuilder.build()</code>来实现。</p><p>我们来看看它内部存储着一些什么信息：</p><ul><li><code>ImageType</code>：若为<code>ImageType.SMALL</code>，则所请求的图片会存储在专用小文件缓存中。具体参考<a href="http://fresco-cn.org/docs/caching.html" target="_blank" rel="external">Fresco缓存</a>；</li><li><code>SourceUri</code>：图片源Uri；</li><li><code>SourceFile</code>：图片文件地址（若是本地文件的话）；</li><li><code>ProgressiveRenderingEnabled</code> 若为true，则这个图片请求会返回质量递进的几次图片信息（渐进式图片）；</li><li><code>LocalThumbnailPreviewsEnabled</code> 若为true，则这个图片请求会在访问本地图片时先返回一个缩略图；</li><li><code>ResizeOptions</code> 缩放尺寸，仅支持JPEG，而且不是每次都需要在ImageRequest中设置缩放尺寸的，具体使用请参照<a href="http://fresco-cn.org/docs/resizing-rotating.html#" target="_blank" rel="external">Fresco缩放和旋转图片</a>；</li><li><code>AutoRotateEnabled</code> 是否允许图片旋转，具体参照<a href="http://fresco-cn.org/docs/resizing-rotating.html#" target="_blank" rel="external">Fresco缩放和旋转图片</a>；</li><li><code>RequestPriority</code> 这个请求的优先级：</li><li><code>LowestPermittedRequestLevel</code> 最低允许从哪层缓存中取数据，参考<a href="http://fresco-cn.org/docs/image-requests.html#" target="_blank" rel="external">最低请求级别</a>；</li><li><code>IsDiskCacheEnabled</code> 若为false，则此图片请求不会从文件缓存中获取数据；</li><li><code>PostProcessor</code> 在图片请求成功之后对图片的处理操作，参考<a href="http://fresco-cn.org/docs/modifying-image.html#_" target="_blank" rel="external">修改图片</a>。</li></ul><p>DraweeController是使用ImageRequest来初始化数据订阅者的。<code>SimpleDraweeView</code>调用<code>setUri(Uri)</code>会产生一个默认的<code>ImageRequest</code>含有指定Uri信息，如果需要修改<code>ImageRequest</code>其他信息，必须手动创建<code>ImageRequest</code>，并在<code>PipelineDraweeControllerBuilder</code>调用<code>.build()</code>之前使用<code>.setImageRequest</code>设置它。</p><h3 id="3-2-可关闭的引用"><a href="#3-2-可关闭的引用" class="headerlink" title="3.2 可关闭的引用"></a>3.2 可关闭的引用</h3><p>Facebook在Java中实现了具有引用计数功能的类：<code>SharedReference&lt;T&gt;</code>（注意不是Android里的SharedPreference）。它将类型为<code>T</code>的对象进行包装，为其实现增加引用数、减少引用数、删除引用的功能。</p><p>特别地，它会使用专门用于实现释放资源的接口：<code>ResourceReleaser&lt;T&gt;</code>，它内部只有一个函数：<code>void release(T object)</code>。</p><p>当然，但是直接让程序员直接去操作它很可能会出现问题。所以<code>CloseableReference</code>出现了，它为任何实现了<code>Closeable</code>类的对象封装了引用计数、回收引用的功能。</p><p><code>CloseableReference</code>中有几个主要函数：</p><ul><li><code>CloseableReference&lt;T&gt; of(T object, ResourceReleaser&lt;T&gt; releaser)</code> <strong>用于初始化引用计数（而不是使用构造函数）</strong>，该函数会新建一个<code>SharedReference</code>将对象包装起来，引用计数为1。若不传releaser，会使用默认的<code>ResourceReleaser</code>，调用<code>Closeable.close()</code>函数回收<code>Closeable</code>引用；</li><li><code>CloseableReference&lt;T&gt; clone()</code> 用于添加对象引用，该函数会新建一个<code>CloseableReference</code>，同时持有的<code>SharedReference</code>引用+1， <strong>不会创建<code>SharedReference</code>对象</strong>；</li><li><code>T get()</code> 返回引用对象；</li><li><code>void close()</code> 减少一个引用计数，若引用计数减为0，则调用releaser的<code>release(T object)</code>将对象释放。<strong>一旦创建了一个CloseableReference，当持有者离开作用域时就必须调用这个函数！（finally函数块是释放资源工作最好的地方）</strong></li></ul><p>最好不要直接使用这个工具，如果非用不可的话，你需要谨慎地操作它。使用方法参考<a href="http://fresco-cn.org/docs/closeable-references.html#_" target="_blank" rel="external">Fresco中文文档</a>。</p><p>Fresco中定义了<code>CloseableImage</code>，它会在<code>finalize</code>的时候调用<code>close()</code>，有这两个类继承了它：</p><ul><li><code>CloseableStaticBitmap</code> 它内部持有一个<code>CloseableReference&lt;Bitmap&gt;</code>包装目标<code>Bitamp</code>，以及关于图像质量、旋转角度的信息。在<code>close()</code>调用的时候会调用<code>CloseableReference</code>的<code>close()</code>函数释放资源，<strong>释放的原理是Bitmap.recycle()</strong>；</li><li><code>CloseableAnimatedBitmap</code> 它内部持有一个<code>List&lt;CloseableReference&lt;Bitmap&gt;&gt;</code>包装起每一帧的<code>Bitmap</code>，还存有每一帧的时长。在<code>close()</code>调用的时候会递归释放列表资源。</li></ul><h3 id="3-3-数据订阅"><a href="#3-3-数据订阅" class="headerlink" title="3.3 数据订阅"></a>3.3 数据订阅</h3><p>Fresco中使用DataSource与DataScriber进行异步数据请求。DataSubscriber具有以下几个函数：</p><ul><li><code>onNewResult</code> 在接收到新的数据；</li><li><code>onFailure</code> 数据加载失败；</li><li><code>onCancellation</code> 数据请求被取消；</li><li><code>onProgressUpdate</code> 加载进度更新。</li></ul><p>DataSource在接受到Image Pipeline提供的数据时调用<code>notifyDataSubscribers</code>使DataSubscriber做出反应。</p><p>更多对于数据订阅者的分析见<a href="https://blog.desmondyao.com/2016/04/01/fresco-4-async.md">Fresco源码分析(4) - 异步加载数据</a>。</p><h3 id="3-4-初始化Draweetroller"><a href="#3-4-初始化Draweetroller" class="headerlink" title="3.4 初始化Draweetroller"></a>3.4 初始化Draweetroller</h3><p>在<code>AbstractDraweeControllerBuilder</code>（<code>DraweeControllerBuilder</code>的基类）的<code>build()</code>函数中会调用继承类实现的<code>obtainController()</code>函数，在默认使用的<code>PipelineDraweeControllerBuilder</code>中，它会做三件重要的事情：</p><ul><li><code>obtainDataSourceSupplier()</code> 根据Uri获取数据源<code>DataSource</code>的<a href="https://github.com/desmond1121/Fresco-Source-Analysis/wiki/Fresco%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F#supplier" target="_blank" rel="external">Supplier</a>；</li><li><code>generateUniqueControllerId()</code> 获取独一无二的Controller标识（使用静态递增的<code>AtomicLong</code>变量记录唯一标识）；</li><li><code>getCallerContext()</code> 获取调用者的<code>Context</code>。</li></ul><p>之后将上面得到的三个变量赋值给Controller，若是第一次设置<code>DraweeController</code>，还会相应地初始化这几个组件（若存在的话）：</p><ul><li><code>RetryManager</code> 管理失败重试的组件；</li><li><code>GestureDetector</code> 传递触屏事件的组件；</li><li><code>DeferredReleaser</code> 向主线程消息队列中添加释放资源任务的组件；</li><li><code>ControllerListener</code> 设置回调函数，具体参考 <strong>3.5 使用ControllerListener</strong>；</li><li><code>DraweeHierarchy</code> 设置图层树。</li></ul><p>在<code>setController</code>调用后，如果传入的<code>DraweeController</code>发生了<code>onAttach</code>，它就会调用<code>subtitRequest()</code>提交数据请求（如果还没有提交的话），我们来看看这个函数是怎么实现的：</p><pre><code>protected void submitRequest() {

    //一些初始化工作

    final String id = mId;
    final boolean wasImmediate = mDataSource.hasResult();
    final DataSubscriber&lt;T&gt; dataSubscriber =
        new BaseDataSubscriber&lt;T&gt;() {
          @Override
          public void onNewResultImpl(DataSource&lt;T&gt; dataSource) {
            boolean isFinished = dataSource.isFinished();
            float progress = dataSource.getProgress();
            T image = dataSource.getResult();
            if (image != null) {
              onNewResultInternal(id, dataSource, image, progress, isFinished, wasImmediate);
            } else if (isFinished) {
              onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true);
            }
          }
          @Override
          public void onFailureImpl(DataSource&lt;T&gt; dataSource) {
            onFailureInternal(id, dataSource, dataSource.getFailureCause(), /* isFinished */ true);
          }
          @Override
          public void onProgressUpdate(DataSource&lt;T&gt; dataSource) {
            boolean isFinished = dataSource.isFinished();
            float progress = dataSource.getProgress();
            onProgressUpdateInternal(id, dataSource, progress, isFinished);
          }
        };
    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);
}
</code></pre><p>从这段代码中我们就可以看出初步的逻辑了，它会创建一个<code>DataScriber</code>并将其绑定到<code>DataSource</code>上，随后只要<code>DataSource</code>处理好图片就会为绑定的<code>DataScriber</code>发布消息。通过在<code>AbstractDraweeController</code>中定义的<code>onFailureInternal</code>、<code>onNewResultInternal</code>、<code>onProgressUpdateInternal</code>来对DraweeHierarchy做相应的改动，从而控制显示层。</p><h3 id="3-5-使用ControllerListener"><a href="#3-5-使用ControllerListener" class="headerlink" title="3.5 使用ControllerListener"></a>3.5 使用ControllerListener</h3><p><code>ControllerListener</code> 提供<code>DraweeController</code>主要事件的回调功能，主要有这几个事件：</p><ul><li><code>onSubmit</code> 在提交图片请求时调用；</li><li><code>onFinalImageSet</code> 最终图片加载完成时调用；</li><li><code>onIntermediateImageSet</code> 任何渐进式图片的过渡图片加载完成时调用；</li><li><code>onIntermediateImageFailed</code> 过渡图片加载失败时调用；</li><li><code>onFailure</code> 最终图片加载失败时调用；</li><li><code>onRelease</code> 释放图片资源时调用。</li></ul><p>你可以继承它并在<code>DraweeControllerBuilder</code>中设置，从而实现一些自定义的提醒事件。</p><h2 id="4-类图"><a href="#4-类图" class="headerlink" title="4 类图"></a>4 类图</h2><p><img src="/image/fresco/class_diagram_draweeview.PNG" alt="DraweeView Diagram"></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/源码解析/" rel="tag"># 源码解析</a> <a href="/tags/Fresco/" rel="tag"># Fresco</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/fresco-6-cache/" rel="next" title="Fresco源码分析(6) - 缓存"><i class="fa fa-chevron-left"></i> Fresco源码分析(6) - 缓存</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/fresco-1-drawable/" rel="prev" title="Fresco源码分析(1) - 图像层次与各类Drawable">Fresco源码分析(1) - 图像层次与各类Drawable <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Desmond Yao</p><p class="site-description motion-element" itemprop="description">Android developer.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-时序图"><span class="nav-number">1.</span> <span class="nav-text">1 时序图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-基类DraweeView"><span class="nav-number">2.</span> <span class="nav-text">2 基类DraweeView</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-DraweeHolder"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 DraweeHolder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-GenericDraweeView"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 GenericDraweeView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-SimpleDraweeView"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 SimpleDraweeView</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-DraweeController"><span class="nav-number">3.</span> <span class="nav-text">3 DraweeController</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-ImageRequest"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 ImageRequest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-可关闭的引用"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 可关闭的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-数据订阅"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 数据订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-初始化Draweetroller"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 初始化Draweetroller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-使用ControllerListener"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 使用ControllerListener</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-类图"><span class="nav-number">4.</span> <span class="nav-text">4 类图</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Desmond Yao</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script></body></html>