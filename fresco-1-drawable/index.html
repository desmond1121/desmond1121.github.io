<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/luffy.img?v=5.1.3"><link rel="mask-icon" href="/images/luffy.img?v=5.1.3" color="#222"><meta name="keywords" content="源码解析,Fresco,"><meta name="description" content="首先介绍几种Fresco中的图像层次，了解它们会帮助你理解Fresco加载图像的原理。1 引论：给图像分层次是什么作用？如果你使用过Fresco这个强大的库之后，你就知道它可以在一个图像的加载、绘制过程中实现极大的定制化。你可以设置进度条来显示图片加载/下载的进度，可以设置占位图等到图片加载/下载成功后再显示目标图片，可以让在加载/下载失败后显示失败图片（更多功能参考Fresco中文文档）。Fre"><meta name="keywords" content="源码解析,Fresco"><meta property="og:type" content="article"><meta property="og:title" content="Fresco源码分析(1) - 图像层次与各类Drawable"><meta property="og:url" content="http://blog.desmondyao.com/fresco-1-drawable/index.html"><meta property="og:site_name" content="Desmond&#39;s Blog"><meta property="og:description" content="首先介绍几种Fresco中的图像层次，了解它们会帮助你理解Fresco加载图像的原理。1 引论：给图像分层次是什么作用？如果你使用过Fresco这个强大的库之后，你就知道它可以在一个图像的加载、绘制过程中实现极大的定制化。你可以设置进度条来显示图片加载/下载的进度，可以设置占位图等到图片加载/下载成功后再显示目标图片，可以让在加载/下载失败后显示失败图片（更多功能参考Fresco中文文档）。Fre"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.desmondyao.com/image/fresco/class_diagram_drawables.PNG"><meta property="og:updated_time" content="2017-11-06T12:30:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Fresco源码分析(1) - 图像层次与各类Drawable"><meta name="twitter:description" content="首先介绍几种Fresco中的图像层次，了解它们会帮助你理解Fresco加载图像的原理。1 引论：给图像分层次是什么作用？如果你使用过Fresco这个强大的库之后，你就知道它可以在一个图像的加载、绘制过程中实现极大的定制化。你可以设置进度条来显示图片加载/下载的进度，可以设置占位图等到图片加载/下载成功后再显示目标图片，可以让在加载/下载失败后显示失败图片（更多功能参考Fresco中文文档）。Fre"><meta name="twitter:image" content="http://blog.desmondyao.com/image/fresco/class_diagram_drawables.PNG"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.desmondyao.com/fresco-1-drawable/"><title>Fresco源码分析(1) - 图像层次与各类Drawable | Desmond's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Desmond's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Focus on Java, Android, React Native.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.desmondyao.com/fresco-1-drawable/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Desmond Yao"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Desmond's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Fresco源码分析(1) - 图像层次与各类Drawable</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T20:30:53+08:00">2017-11-06</time></span></div></header><div class="post-body" itemprop="articleBody"><p>首先介绍几种Fresco中的图像层次，了解它们会帮助你理解Fresco加载图像的原理。</p><h2 id="1-引论：给图像分层次是什么作用？"><a href="#1-引论：给图像分层次是什么作用？" class="headerlink" title="1 引论：给图像分层次是什么作用？"></a>1 引论：给图像分层次是什么作用？</h2><p>如果你使用过Fresco这个强大的库之后，你就知道它可以在一个图像的加载、绘制过程中实现极大的定制化。你可以设置进度条来显示图片加载/下载的进度，可以设置占位图等到图片加载/下载成功后再显示目标图片，可以让在加载/下载失败后显示失败图片（更多功能参考<a href="http://fresco-cn.org/docs/" target="_blank" rel="external">Fresco中文文档</a>）。Fresco将进度条、占位图、失败图都作为图像的一层视图来管理，这部分仅仅负责视图层次绘制，将负责视图功能部分与逻辑部分尽可能实现解耦。</p><a id="more"></a><p>Fresco中定义了许多Drawable，它们都直接或间接继承了<code>Drawable</code>，但是各自的功能是不一样的。经过总结，我认为其中一共有三种功能的Drawable：层次型、容器型和视图型。直接上源码的一个视图例子就好理解了，作者进行了适当修改与翻译。</p><p>o 层次型Drawable（维持图层）<br>|<br>—— 容器型Drawable（可对内容进行缩放）<br>|　　　　|<br>|　　　　— 视图型Drawable（存放占位图）<br>|<br>—— 容器型Drawable（可对内容进行缩放）<br>|　　　　|<br>|　　　　—– 容器型Drawable（可多次设置内容）<br>|　　　　　　　|<br>|　　　　　　　— 视图型Drawable（存放目标显示图片）<br>|<br>—— 容器型Drawable（可对内容进行缩放）<br>|　　　　|<br>|　　　　— 视图型Drawable（存放重试图片）<br>|<br>—— 容器型Drawable（可对内容进行缩放）<br>　　　　|<br>　　　　— 视图型Drawable（存放失败图片）</p><p>该例位于<code>com.facebook.drawee.generic.GenericDraweeHierarchy</code>的类注释中。</p><p>这个例子充分描述了一个图像的层次，当然也可以在设置的时候往里面自行设置所需要的图层。</p><h2 id="2-层次型Drawable"><a href="#2-层次型Drawable" class="headerlink" title="2 层次型Drawable"></a>2 层次型Drawable</h2><p>在这一节中介绍的Drawable并不直接负责具体图像绘制，而是负责组建图像层次。</p><h3 id="2-1-ArrayDrawable"><a href="#2-1-ArrayDrawable" class="headerlink" title="2.1 ArrayDrawable"></a>2.1 ArrayDrawable</h3><p><code>ArrayDrawable</code>内部存储着一个Drawable数组，它与Android内置的<code>LayerDrawable</code>很相似，可见它将数组中的<code>Drawable</code>当做它的图层，在绘制的时候<code>ArrayDrawable</code>会按照数组顺序绘制其中的图层，数组最后的成员会显示在最上方。不过与<code>LayerDrawable</code>最大的不同的点有两处：</p><ul><li>绘制顺序虽然是数组顺序，但是<code>ArrayDrawable</code>在绘制时会跳过暂时不需要绘制的图层；</li><li>在<code>ArrayDrawable</code>中不支持动态的添加/删除图层，只能在初始化时通过传入的数组决定图层数。不过好在它能够为存在的图层更换Drawable。（关于<code>LayerDrawable</code>可以参考我翻译的一文章：<a href="http://blog.csdn.net/desmondj/article/details/47751553" target="_blank" rel="external">Android LayerDrawable</a>。）</li></ul><h3 id="2-2-FadeDrawable"><a href="#2-2-FadeDrawable" class="headerlink" title="2.2 FadeDrawable"></a>2.2 FadeDrawable</h3><p><code>FadeDrawable</code>继承了<code>ArrayDrawable</code>。它除了具有<code>ArrayDrawable</code>本身的功能之外，还提供隐藏/显示图层的功能（可设置渐变）。具体的几个核心函数有：</p><ul><li><code>setTransitionDuration(int durationMs)</code> 设置隐藏/显示图层渐变动画时间（默认为300ms）。</li><li><code>fadeInLayer(int index)</code> 显示指定图层</li><li><code>fadeOutLayer(int index)</code> 隐藏指定图层</li><li><code>fadeInAllLayers()</code> 显示所有图层</li><li><code>fadeOutAllLayers()</code> 隐藏所有图层</li><li><code>fadeToLayer(int index)</code> 显示指定图层同时隐藏其他图层</li><li><code>fadeUpToLayer(int index)</code> 隐藏数组下标&lt;=index的图层</li></ul><p>它内部维护着一个boolean数组来维持需要显示的图层（可以调用<code>isLayerOn(int inxex)</code>查看指定图层是否显示）。</p><h2 id="3-容器型Drawable"><a href="#3-容器型Drawable" class="headerlink" title="3 容器型Drawable"></a>3 容器型Drawable</h2><p><strong>ForwardingDrawable</strong></p><p><code>ForwardingDrawable</code>通俗的来说就是图片容器。它内部维护一个<code>Drawable</code>变量<code>mCurrentDelegate</code>，将Drawable的基本函数以及一些回调函数传递给目标图片，并在<code>draw(Canvas)</code>函数中调用<code>mCurrentDeletate.draw(Canvas)</code>函数将目标图片绘制出来。<br>它可以通过<code>getCurrent()</code>来获取容器内容，起到一个相当于是传递树的作用。它是所有容器型Drawable的基类，以下介绍几个它的子类，他们实现了不同功能的容器包装。</p><p><strong>ScaleTypeDrawable</strong></p><p><code>ScaleTypeDrawable</code>封装了对代理图片的缩放处理，具体的缩放参数（<code>ScaleType</code>）与<a href="http://developer.android.com/reference/android/widget/ImageView.ScaleType.html" target="_blank" rel="external">Android ScaleType</a>的名字、功能相同。它在处理图片缩放的时候与<code>ImageView</code>的处理方式相似，我们来看一下它是怎么处理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureBoundsIfUnderlyingChanged</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">/* 当图像尺寸改变后，就重新确定图像边缘 */</span></div><div class="line">  <span class="keyword">if</span> (mUnderlyingWidth != getCurrent().getIntrinsicWidth() ||</div><div class="line">      mUnderlyingHeight != getCurrent().getIntrinsicHeight()) &#123;</div><div class="line">    configureBounds();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>mUnderLyingWidth</code>与<code>mUnderLyingHeight</code>维护了已知的上一张图片宽高（初始均为0），当要绘制时调用这个函数，如果与上一张绘制的图像不一样时，就重新确认绘制边缘与缩放矩阵。</p><p>再来看一下<code>configureBounds()</code>是怎么确定转换矩阵的吧：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureBounds</span><span class="params">()</span> </span>&#123;</div><div class="line">   ...</div><div class="line">   <span class="comment">// 特殊情况判断：绘制图片是否为空白图或与之前绘制的图片尺寸相同</span></div><div class="line">   ...</div><div class="line"></div><div class="line">   <span class="comment">// 当要往X、Y方向上填充容器时，直接将目标图片边界设置成容器图片的边界即可，Drawable会在绘制的时候自己调整。</span></div><div class="line">   <span class="keyword">if</span> (mScaleType == ScalingUtils.ScaleType.FIT_XY) &#123;</div><div class="line">     underlyingDrawable.setBounds(bounds);</div><div class="line">     mDrawMatrix = <span class="keyword">null</span>;</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//处理其他缩放情况</span></div><div class="line">   underlyingDrawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, underlyingWidth, underlyingHeight);</div><div class="line">   ScalingUtils.getTransform(</div><div class="line">       mTempMatrix,</div><div class="line">       bounds,</div><div class="line">       underlyingWidth,</div><div class="line">       underlyingHeight,</div><div class="line">       (mFocusPoint != <span class="keyword">null</span>) ? mFocusPoint.x : <span class="number">0.5f</span>,</div><div class="line">       (mFocusPoint != <span class="keyword">null</span>) ? mFocusPoint.y : <span class="number">0.5f</span>,</div><div class="line">       mScaleType);</div><div class="line">   mDrawMatrix = mTempMatrix;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p></p><p>这里通过<code>ScalingUtils.getTransform</code>来计算出变换矩阵，我们以<code>CENTER_INSIDE</code>为例研究一下它的工作机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Matrix <span class="title">getTransform</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Matrix transform,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Rect parentBounds,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> childWidth,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> childHeight,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">float</span> focusX,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">float</span> focusY,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ScaleType scaleType)</span> </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scaleX = (<span class="keyword">float</span>) parentWidth / (<span class="keyword">float</span>) childWidth;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scaleY = (<span class="keyword">float</span>) parentHeight / (<span class="keyword">float</span>) childHeight;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">switch</span>(scaleType)&#123;</div><div class="line">		...</div><div class="line">		<span class="keyword">case</span> CENTER_INSIDE:</div><div class="line">		        <span class="comment">//计算缩放倍数</span></div><div class="line">			    scale = Math.min(Math.min(scaleX, scaleY), <span class="number">1.0f</span>);</div><div class="line">			    <span class="comment">//计算平移距离</span></div><div class="line">		        dx = parentBounds.left + (parentWidth - childWidth * scale) * <span class="number">0.5f</span>;</div><div class="line">		        dy = parentBounds.top + (parentHeight - childHeight * scale) * <span class="number">0.5f</span>;</div><div class="line">		        <span class="comment">//设置缩放矩阵</span></div><div class="line">		        transform.setScale(scale, scale);</div><div class="line">		        <span class="comment">//设置评议距离</span></div><div class="line">		        transform.postTranslate((<span class="keyword">int</span>) (dx + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (dy + <span class="number">0.5f</span>));</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其他具体的<code>ScaleType</code>处理就不赘述了，有兴趣的同学可以自己看源码再研究。<strong>默认的ScaleType是CENTER_CROP。</strong></p><p>在计算好矩阵之后，我们来看一下这个容器是怎么将它的内容绘制出来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">  <span class="comment">//计算矩阵</span></div><div class="line">  configureBoundsIfUnderlyingChanged();</div><div class="line">  <span class="keyword">if</span> (mDrawMatrix != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">int</span> saveCount = canvas.save();</div><div class="line">    canvas.clipRect(getBounds());</div><div class="line">    canvas.concat(mDrawMatrix);</div><div class="line">    <span class="keyword">super</span>.draw(canvas);</div><div class="line">    canvas.restoreToCount(saveCount);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//无变换矩阵时，直接让Drawable绘制到确定的边缘中。</span></div><div class="line">    <span class="keyword">super</span>.draw(canvas);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以看到它将矩阵应用到<code>Canvas</code>中，并调用<code>ForwardingDrawable</code>的<code>draw(Canvas)</code>让它将目标视图绘制出来，之后还原Canvas的缩放属性防止累加缩放。</p><p><em>暂时先介绍各类容器Drawable的功能，为方便后续理解。待分析完Fresco的架构之后再为分析。</em></p><ul><li><strong>SettableDrawable</strong>：可以多次设置内容Drawable的容器，多用在目标图片的图层中。</li><li><strong>AutoRotateDrawable</strong>：提供内容动态旋转的容器。</li><li><strong>OrientedDrawable</strong>：可以将内容Drawable以一个特定的角度绘制的容器。</li><li><strong>MatrixDrawable</strong>：可以为内容应用变形矩阵的容器，它只能赋予给显示目标图片的那个图层。<strong><em>不能在一个图层上同时使用MatrixDrawable与ScaleTypeDrawable！</em></strong></li><li><strong>RoundedCornersDrawable</strong>：可以将内容的边界修剪成圆角矩形（目前版本暂不支持）或用实心的圆角矩形覆盖内容的容器。</li><li><strong>GenericDraweeHierarchy.RootDrawable</strong>：专门用于顶层图层的容器。</li></ul><h2 id="4-视图型Drawable"><a href="#4-视图型Drawable" class="headerlink" title="4 视图型Drawable"></a>4 视图型Drawable</h2><p>大多数情况下，Fresco用于表现图片的视图型Drawable使用的就是Android原生<code>Drawable</code>来做图像的载体。不过也有两个例外：</p><p><strong>ProgressBarDrawable</strong></p><p><code>ProgressBarDrawable</code>是负责绘制进度条的Drawable。它内部维持一个<code>level</code>用来描述进度(0&lt;=level&lt;=10000)，并自己实现了绘制过程，我们首先通过源码来看一下是怎么绘制的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (mHideWhenZero &amp;&amp; mLevel == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  drawBar(canvas, <span class="number">10000</span>, mBackgroundColor);</div><div class="line">  drawBar(canvas, mLevel, mColor);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBar</span><span class="params">(Canvas canvas, <span class="keyword">int</span> level, <span class="keyword">int</span> color)</span> </span>&#123;</div><div class="line">  Rect bounds = getBounds();</div><div class="line">  <span class="keyword">int</span> length = (bounds.width() - <span class="number">2</span> * mPadding) * level / <span class="number">10000</span>;</div><div class="line">  <span class="keyword">int</span> xpos = bounds.left + mPadding;</div><div class="line">  <span class="keyword">int</span> ypos = bounds.bottom - mPadding - mBarWidth;</div><div class="line">  mPaint.setColor(color);</div><div class="line">  canvas.drawRect(xpos, ypos, xpos + length, ypos + mBarWidth, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看出，它先将整个进度条填充满<code>backgroundColor</code>颜色(可以通过<code>setBackgroundColor</code>设置)，再将进度覆盖区域矩形填充满<code>color</code>颜色(可以通过<code>setColor</code>设置)。</p><p><strong>RoundedBitmapDrawable</strong></p><p>这个Drawable与上面的容器型<code>RoundedCornersDrawable</code>有几个区别：</p><p><code>RoundedBitmapDrawable</code>是将自身内容修剪成圆角矩形边绘制出来，并且可以使用Bitmap作为对象，返回一个<code>BitmapDrawable</code>。而<code>RoundedCornersDrawable</code>是将容器内容修剪成圆角矩形边，并且可以选择是否用指定颜色覆盖容器内容，可以使用任何Drawable当做容器。</p><p><em>待分析完Fresco的架构之后，会回来分析圆角图片的实现机制。它与正常的使用Xfermode实现方式不同。</em></p><p>实际上这两个类的功能是有一定重合的，我认为是由于<code>RoundedCornerDrawable</code>目前只能做到用圆角矩形覆盖内容，而无法将内容修剪成圆角矩形，所以才使用了<code>RoundedBitmapDrawable</code>。关于<code>RoundedCornersDrawable</code>的功能Fresco也在改进中。期待后续它能将两个功能合并起来。</p><h2 id="5-特殊Drawable-TransformAwareDrawable-和-VisibilityAwareDrawable"><a href="#5-特殊Drawable-TransformAwareDrawable-和-VisibilityAwareDrawable" class="headerlink" title="5 特殊Drawable - TransformAwareDrawable 和 VisibilityAwareDrawable"></a>5 特殊Drawable - TransformAwareDrawable 和 VisibilityAwareDrawable</h2><p>为什么说它们特殊呢，因为他们只是接口！</p><p><code>TransformAwareDrawable</code>要和<code>TransfromCallback</code>一起使用。<code>TransformAwareDrawable</code>的作用很简单，就是提供设置<code>TransfromCallback</code>的回调函数，那我们来看看<code>TransfromCallback</code>的作用是什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface TransformCallback &#123;</div><div class="line"></div><div class="line">  // 获取已经应用在自身的变换Matrix，储存在transfrom中。</div><div class="line">  public void getTransform(Matrix transform);</div><div class="line"></div><div class="line">  // 获取根节点边界，储存在bounds中。</div><div class="line">  public void getRootBounds(RectF bounds);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之所以要设置这个回调，是因为本篇中的Drawable是有层次的。如果B 是 A的子图层，那应用在A上的变换矩阵自然应该应用到B上，所以提供这个回调可以让B获取应用在A上的变换矩阵，从而正确地进行绘制。</p><p><strong>在本篇文章中出现的所有Drawable都实现了<code>TransformAwareDrawable</code>与<code>TransfromCallback</code>。</strong> 在<code>ArrayDrawable</code>中的<code>getTransfrom</code>中可以看出它的工作机制（实际上除了个别自身有缩放的图层如<code>ScaleTypeDrawable</code>, <code>MatrixDrawable</code>外的实现都是想以下这段代码一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTransform</span><span class="params">(Matrix transform)</span> </span>&#123;</div><div class="line">  <span class="comment">//如果有父图层，则获取应用在父图层上的变换矩阵</span></div><div class="line">  <span class="keyword">if</span> (mTransformCallback != <span class="keyword">null</span>) &#123;</div><div class="line">    mTransformCallback.getTransform(transform);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">//如果没有父图层，就获取单位矩阵</span></div><div class="line">    transform.reset();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>ScaleTypeDrawable</code>和<code>MatrixDrawable</code>中会将自身的变换矩阵通过<code>Matrix.confat(Matrix m)</code>传给<code>transform</code>。如此一来就实现了变换矩阵向下传递的功能。</p><p><code>VisibilityAwareDrawable</code>与<code>VisibilityCallback</code>搭配使用，它提供了在自身可见度改变的时候的通知函数（<code>onVisibilityChange(boolean visible)</code>）和在自身绘制时发生通知的回调(<code>onDraw()</code>)。仅仅<code>GenericDraweeHierarchy.RootDrawable</code>实现了它。</p><h2 id="6-类图"><a href="#6-类图" class="headerlink" title="6 类图"></a>6 类图</h2><p>由于类中方法、变量过多，作者对其做了大量精简，仅用于参考设计层次。</p><p><img src="/image/fresco/class_diagram_drawables.PNG" alt="Class Diagram"></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/源码解析/" rel="tag"># 源码解析</a> <a href="/tags/Fresco/" rel="tag"># Fresco</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/flatbuffers/" rel="next" title="使用FlatBuffers来提升Facebook客户端在Android上的性能"><i class="fa fa-chevron-left"></i> 使用FlatBuffers来提升Facebook客户端在Android上的性能</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/butterknife/" rel="prev" title="ButterKnife解析">ButterKnife解析 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Desmond Yao</p><p class="site-description motion-element" itemprop="description">Android developer.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/desmond1121" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://weibo.com/u/1901104743" target="_blank" title="Weibo"><i class="fa fa-fw fa-globe"></i>Weibo</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://kaedea.com/" title="Kaedea" target="_blank">Kaedea</a></li><li class="links-of-blogroll-item"><a href="http://yrom.net/" title="Yrom" target="_blank">Yrom</a></li><li class="links-of-blogroll-item"><a href="http://blog.zhaiyifan.cn/" title="MarkZhai" target="_blank">MarkZhai</a></li><li class="links-of-blogroll-item"><a href="http://abner-nimengbo.cn/" title="泥阿布" target="_blank">泥阿布</a></li><li class="links-of-blogroll-item"><a href="https://xiequan.info" title="谢权" target="_blank">谢权</a></li><li class="links-of-blogroll-item"><a href="http://rarnu.com/" title="何老师" target="_blank">何老师</a></li><li class="links-of-blogroll-item"><a href="http://fucknmb.com/" title="区长" target="_blank">区长</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-引论：给图像分层次是什么作用？"><span class="nav-number">1.</span> <span class="nav-text">1 引论：给图像分层次是什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-层次型Drawable"><span class="nav-number">2.</span> <span class="nav-text">2 层次型Drawable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-ArrayDrawable"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 ArrayDrawable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-FadeDrawable"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 FadeDrawable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-容器型Drawable"><span class="nav-number">3.</span> <span class="nav-text">3 容器型Drawable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-视图型Drawable"><span class="nav-number">4.</span> <span class="nav-text">4 视图型Drawable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-特殊Drawable-TransformAwareDrawable-和-VisibilityAwareDrawable"><span class="nav-number">5.</span> <span class="nav-text">5 特殊Drawable - TransformAwareDrawable 和 VisibilityAwareDrawable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-类图"><span class="nav-number">6.</span> <span class="nav-text">6 类图</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Desmond Yao</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script></body></html>