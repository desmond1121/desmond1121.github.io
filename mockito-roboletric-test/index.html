<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/luffy.img?v=5.1.3"><link rel="mask-icon" href="/images/luffy.img?v=5.1.3" color="#222"><meta name="keywords" content="Android,TDD,"><meta name="description" content="好的测试用例常常能让开发效率和质量大大提升，但是代码设计有时候会使测试用例无从下手、难以书写，神烦，很多时候会让开发者忽略做单元测试，又或干脆就懒得写了。在开源界也涌出了很多优秀的单元测试框架，就是为了弥补“单元测试不好写”这个缺陷:Mockito 强大的模拟工具，能够模拟出无关的依赖模块、行为，并能够验证调用顺序；Roboletric 在JVM上模拟Android测试环境（即通过单元测试就能测试"><meta name="keywords" content="Android,TDD"><meta property="og:type" content="article"><meta property="og:title" content="使用Mockito和Roboletric进行Android单元测试"><meta property="og:url" content="http://blog.desmondyao.com/mockito-roboletric-test/index.html"><meta property="og:site_name" content="Desmond&#39;s Blog"><meta property="og:description" content="好的测试用例常常能让开发效率和质量大大提升，但是代码设计有时候会使测试用例无从下手、难以书写，神烦，很多时候会让开发者忽略做单元测试，又或干脆就懒得写了。在开源界也涌出了很多优秀的单元测试框架，就是为了弥补“单元测试不好写”这个缺陷:Mockito 强大的模拟工具，能够模拟出无关的依赖模块、行为，并能够验证调用顺序；Roboletric 在JVM上模拟Android测试环境（即通过单元测试就能测试"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.desmondyao.com/image/robo-config.png"><meta property="og:updated_time" content="2017-11-06T12:30:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用Mockito和Roboletric进行Android单元测试"><meta name="twitter:description" content="好的测试用例常常能让开发效率和质量大大提升，但是代码设计有时候会使测试用例无从下手、难以书写，神烦，很多时候会让开发者忽略做单元测试，又或干脆就懒得写了。在开源界也涌出了很多优秀的单元测试框架，就是为了弥补“单元测试不好写”这个缺陷:Mockito 强大的模拟工具，能够模拟出无关的依赖模块、行为，并能够验证调用顺序；Roboletric 在JVM上模拟Android测试环境（即通过单元测试就能测试"><meta name="twitter:image" content="http://blog.desmondyao.com/image/robo-config.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.desmondyao.com/mockito-roboletric-test/"><title>使用Mockito和Roboletric进行Android单元测试 | Desmond's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Desmond's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Focus on Java, Android, React Native.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.desmondyao.com/mockito-roboletric-test/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Desmond Yao"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Desmond's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">使用Mockito和Roboletric进行Android单元测试</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-06T14:39:59+08:00">2016-07-06</time></span></div></header><div class="post-body" itemprop="articleBody"><p>好的测试用例常常能让开发效率和质量大大提升，但是代码设计有时候会使测试用例无从下手、难以书写，神烦，很多时候会让开发者忽略做单元测试，又或干脆就懒得写了。在开源界也涌出了很多优秀的单元测试框架，就是为了弥补“单元测试不好写”这个缺陷:</p><ul><li><a href="http://mockito.org/" target="_blank" rel="external">Mockito</a> 强大的模拟工具，能够模拟出无关的依赖模块、行为，并能够验证调用顺序；</li><li><a href="https://github.com/robolectric/robolectric" target="_blank" rel="external">Roboletric</a> 在JVM上模拟Android测试环境（即通过单元测试就能测试部分Android代码）。</li></ul><a id="more"></a><p>本文结合这两个库来介绍一下在Android开发中如何写单元测试。</p><h2 id="为什么要单元测试？"><a href="#为什么要单元测试？" class="headerlink" title="为什么要单元测试？"></a>为什么要单元测试？</h2><p>在写单元测试的时候，你需要想明白这个问题，才能更有针对性地去写测试用例。</p><p>单元测试的好处体现在于：</p><ol><li>你做了一个很大的底层改动，跑一遍单元测试，哇，全通过了！测试通过让你有信心将代码发布出去；</li><li>在写测试的时候你会对自己的代码进行思考，每一个操作应用后将会产生什么样的期望后果；</li><li>在快速开发时，写几个单元测试保证代码质量。</li></ol><p>就拿<a href="https://github.com/facebook/fresco" target="_blank" rel="external">Fresco</a>里面的单元测试举个例子，它测试<code>DraweeView</code>在attach/detach到Window上时的反应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLifecycle_Controller</span><span class="params">()</span> </span>&#123;</div><div class="line">    InOrder inOrder = inOrder(mController); <span class="comment">// 初始化mockito类，验证调用顺序</span></div><div class="line">    mDraweeView.setHierarchy(mDraweeHierarchy);</div><div class="line">    mDraweeView.setController(mController);</div><div class="line"></div><div class="line">    inOrder.verify(mController).setHierarchy(mDraweeHierarchy); <span class="comment">// 是否调用了setHierarchy</span></div><div class="line">    mDraweeView.onAttachedToWindow(); <span class="comment">// 模拟View attachWindow 事件</span></div><div class="line">    inOrder.verify(mController).onAttach(); <span class="comment">// 是否调用了 onAttach</span></div><div class="line">    mDraweeView.onStartTemporaryDetach(); <span class="comment">// 模拟View temporaryDetach 事件</span></div><div class="line">    inOrder.verify(mController).onDetach(); <span class="comment">// 是否调用了 onDetach</span></div><div class="line">    mDraweeView.onFinishTemporaryDetach(); <span class="comment">// 模拟View finishTemporaryDetach 事件</span></div><div class="line">    inOrder.verify(mController).onAttach(); <span class="comment">// 是否调用了 onAttach （结束临时detach，即应该重新attach）</span></div><div class="line">    mDraweeView.onDetachedFromWindow(); <span class="comment">// 模拟View detach 事件</span></div><div class="line">    inOrder.verify(mController).onDetach();  <span class="comment">// 是否调用了 onDetach</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面这段测试用例很简单，但是功能很强大，它保证了这个<code>DraweeView</code>在View的attach/detach处理这个环节的代码正确。</p><p>StackOverflow上有个<a href="http://stackoverflow.com/questions/67299/is-unit-testing-worth-the-effort" target="_blank" rel="external">回答</a>很棒，你只有开始写单元测试后才能体会到它的强大，那么我们来学习一下吧。</p><h2 id="Mockito的作用"><a href="#Mockito的作用" class="headerlink" title="Mockito的作用"></a>Mockito的作用</h2><p>通常组件之间都会有模块化依赖，但是写单元测试时一般仅涉及一两个组件，若要复现操作环境是非常困难的事情。而Mockito能够轻易Mock一个依赖模块实例，并指定它的行为，把精力用在你想要的那一小个单元的测试。</p><h3 id="1-Mock-模拟行为"><a href="#1-Mock-模拟行为" class="headerlink" title="1. Mock 模拟行为"></a>1. Mock 模拟行为</h3><p>这是它的精髓之一，可以通过注解<code>@Mock</code>(语法糖)或者<code>Mockito.mock(Class&lt;T&gt; clazz)</code>模拟出一个实例，传入的不论是Interface, Abstract class还是普通Class，统统都会mock出一个继承原类、填满hook的新类。注意这个生成的新类是一个空壳，如果需要使用必须指定行为（Stub）。对于未Stub的方法，通常返回null。我们可以写个test来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//test</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExambleClassTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Mock</span> ExampleClass mTestClass;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>); <span class="comment">// 初始化被@Mock注解的类</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrigin</span><span class="params">()</span> </span>&#123;</div><div class="line">        Assert.assertEquals(<span class="string">"test"</span>, mTestClass.test()); <span class="comment">// Fail</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMock</span><span class="params">()</span> </span>&#123;</div><div class="line">        Mockito.when(mTestClass.test()).thenReturn(<span class="string">"testMock"</span>);</div><div class="line">        Assert.assertEquals(<span class="string">"testMock"</span>, mTestClass.test()); <span class="comment">// Success</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面这段测试用例中，<code>testOrigin()</code>会报失败，因为<code>test()</code>方法被hook后返回了null。<code>testMock()</code>会成功，因为我们把这个方法Stub住了，让它返回了”testMock”。</p><p>除了mock，还有另一种用法：<code>@Spy/spy(Class&lt;T&gt; clazz)</code>。它可以对一个类的实例（或者含有无参构造函数的类）进行模拟，未指定行为的方法由原类处理，指定行为的类由hook处理。对上面的<code>ExampleClass</code>，我们可以用Spy来进行一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClassTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Spy</span> ExampleClass mExampleClass;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// Success</span></div><div class="line">        Assert.assertEquals(<span class="string">"test"</span>, mExampleClass.test());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMockSpy</span><span class="params">()</span> </span>&#123; <span class="comment">// Success</span></div><div class="line">        Mockito.doReturn(<span class="string">"mockSpy"</span>).when(mExampleClass).test();</div><div class="line">        Assert.assertEquals(<span class="string">"mockSpy"</span>, mExampleClass.test());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里<code>testOrigin()</code>和<code>testMockSpy()</code>都会通过（注意在<code>@Mock</code>注释下<code>testOrigin()</code>会失败)，因为<code>Spy</code>只是部分Mock，对没有模拟行为的部分仍返回原结果，但是用起来也会不一样，具体看下文。</p><p><strong>模拟行为</strong>（Stub）一共有两类做法：</p><ul><li><code>Mockito.when(obj.methodCall()).thenReturn(result);</code> 会检查返回类型；不可用于重复Stub、返回void的函数、Spy作用下mock类的call。</li><li><code>Mockito.doReturn(result).when(obj).methodCall();</code> 不会检查返回类型，可重复Stub</li></ul><p>之所以说是两类做法，是因为里面的所有<code>return</code>都可以换成<code>answer</code>，不仅指定返回，还可以指定methodCall中做的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountClass</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试用例</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountClassTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Mock</span> CountClass mTestClass;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">        Mockito.doAnswer(<span class="keyword">new</span> Answer&lt;Void&gt; &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                mTestClass.count += <span class="number">2</span>;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;).when(mTestClass).addCount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMockVoid</span><span class="params">()</span> </span>&#123; <span class="comment">// Success</span></div><div class="line">        mTestClass.addCount();</div><div class="line">        Assert.assertEquals(<span class="number">2</span>, mTestClass.count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>ps: 如上调用是唯一一种Stub void返回函数的做法。</p></blockquote><h3 id="2-验证行为"><a href="#2-验证行为" class="headerlink" title="2. 验证行为"></a>2. 验证行为</h3><p>由于Mockito在mock出来的对象中四处都是hook，所以它可以做到一个很棒的功能：验证调用。基于上文的<code>CountClass</code>你可以写一个如下的简单测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddCount</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    mCountClass.addCount();</div><div class="line">    mCountClass.addCount();</div><div class="line">    Mockito.verify(mCountClass, <span class="keyword">new</span> Times(<span class="number">2</span>)).addCount();</div><div class="line">    Assert.assertEquals(<span class="number">4</span>, mCountClass.count);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-题外话"><a href="#3-题外话" class="headerlink" title="3. 题外话"></a>3. 题外话</h3><p><code>when(obj.methodCall()).thenReturn(something)</code>时这个方法到底有没有被执行呢？我感到很好奇。于是我试验了一下，发现它确实是被调用了，但是是无法用<code>Mockito.verify</code>验证到的。你可以跑一下如下测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Mock</span> TestClass mTestClass;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        Mockito.when(mTestClass.addCount()).thenAnswer(ew Answer&lt;String&gt; &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">              mTestClass.count += <span class="number">2</span>;</div><div class="line">              <span class="keyword">return</span> <span class="string">"test"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Mockito.when(mTestClass.addCount()).thenAnswer(ew Answer&lt;String&gt; &#123;  <span class="comment">//此处会调用一次第一次的Stub</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">              mTestClass.count += <span class="number">2</span>;</div><div class="line">              <span class="keyword">return</span> <span class="string">"test"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Assert.assertEquals(<span class="number">2</span>, mCountClass.count); <span class="comment">// Success</span></div><div class="line">        Mockito.verify(mTestClass).addCount(); <span class="comment">// Fail</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Mockito.when(mTestClass.addCount()).thenAnswer()</code> 这里一共有三步： mTestClass.addCount() -&gt; when() -&gt; thenAnswer()。</p><p>由于<code>mTestClass.addCount()</code>确实被调用了，所以它产生的后果是持久性的，所以后续验证<code>mCountClass.count==2</code>是对的。但是这里又蛮有意思的，为什么不会被verify？我去翻阅了一下源码，发现了两处相关代码，供大家理解：</p><h4 id="3-1-MockHandlerImpl中处理函数调用："><a href="#3-1-MockHandlerImpl中处理函数调用：" class="headerlink" title="3.1 MockHandlerImpl中处理函数调用："></a>3.1 <code>MockHandlerImpl</code>中处理函数调用：</h4><p>这里就是所有的mock对象hook处理集中处，它是类似动态代理的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 将此次调用设置为可能的Stub对象</span></div><div class="line">    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);</div><div class="line">    OngoingStubbingImpl&lt;T&gt; ongoingStubbing = <span class="keyword">new</span> OngoingStubbingImpl&lt;T&gt;(invocationContainerImpl);</div><div class="line">    mockingProgress.reportOngoingStubbing(ongoingStubbing);</div><div class="line"></div><div class="line">    <span class="comment">// 寻找是否有Stub的方法调用，有则调用，否则返回默认返回</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>setInvocationForPotentialStubbing(invocation)</code>中它将此次调用添加到了一个<code>LinkedList</code>中。</p><h4 id="3-2-OugoingStubbingImpl中添加Stub"><a href="#3-2-OugoingStubbingImpl中添加Stub" class="headerlink" title="3.2 OugoingStubbingImpl中添加Stub"></a>3.2 <code>OugoingStubbingImpl</code>中添加Stub</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OutgoingStubbingImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> OngoingStubbing&lt;T&gt; <span class="title">thenAnswer</span><span class="params">(Answer&lt;?&gt; answer)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果没有可Stub的对象则报错</span></div><div class="line"></div><div class="line">    invocationContainerImpl.addAnswer(answer); <span class="comment">// 将这个Answer设置为Stub返回，并且移除上一个调用记录(肯定是被Stub的函数调用)。</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConsecutiveStubbing&lt;T&gt;(invocationContainerImpl);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InvocationContainerImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnswer</span><span class="params">(Answer answer)</span> </span>&#123;</div><div class="line">    registeredInvocations.removeLast();</div><div class="line">    addAnswer(answer, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里将调用记录，也就是后续verify的时候检查的东西抹去了！</p><p>所以说<code>Mocktio.when(obj.methodCall()).thenAnswer(answer)</code>在<strong>重复Stub</strong>的时候是存在问题的，虽然不会被verify到，但如果Stub的Answer中做了一些持久改变，它会在下次被Stub时的那次调用中生效。多次Stub可以用<code>Mocktio.doReturn(something).when(obj).methodCall()</code>，这里它在真实的调用之前已经将Stub替换掉了，所以不会出现这个问题。</p><h2 id="Roboletric能做的事"><a href="#Roboletric能做的事" class="headerlink" title="Roboletric能做的事"></a>Roboletric能做的事</h2><p>Roboletric是另一个优秀的库，它的目标是你能够用单元测试来测试一些Android相关的代码。正常情况下跟Activity、Service有关的测试需要走<a href="https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html" target="_blank" rel="external">Instrument测试</a>，在实机上跑，然而Robolectric可以让你轻松地在电脑上就跑起Android测试。</p><p>Robolectric使用了自己的<code>ClassLoader</code>，它在UnitTest运行时插入了各类<code>Shadow Object</code>来为Android原生类添加一些hook用于测试。<code>RobolectricTestRunner</code>会从它上传的<code>org.robolectric:android-all</code>里面去拿对应的Android SDK。这个原理比较复杂，先不深究了，主要看看用法吧：</p><h3 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h3><p>首先你有一个<code>MainActivity</code>，它含有<code>R.id.root_view</code>的一个根View，里面有一个<code>Button</code>点击可以跳转<code>SecondActivity</code>。你可以通过以下这段代码来让你的Activity走一遍<code>onCreate-&gt;onStart-&gt;onResume</code>，并做一些检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(RobolectricGradleTestRunner.class)</div><div class="line"><span class="meta">@Config</span>(constants = BuildConfig.class, sdk = <span class="number">21</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityTest</span> </span>&#123;</div><div class="line">    ActivityController&lt;MainActivity&gt; mActivityController;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</div><div class="line">        mActivityController = Robolectric.buildActivity(MainActivity.class).create().start().resume().visible();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBase</span><span class="params">()</span> </span>&#123;</div><div class="line">        Assert.assertTrue(Shadows.shadowOf(mActivityController.get()).isTaskRoot()); <span class="comment">//是否MainActivity在Task root</span></div><div class="line">        ViewGroup view = (ViewGroup) mActivityController.get().findViewById(R.id.root_view);</div><div class="line">        Assert.assertNotNull(view);                     <span class="comment">// 是否存在view</span></div><div class="line">        ShadowView shadow = Shadows.shadowOf(view);</div><div class="line">        Assert.assertTrue(shadow.isAttachedToWindow()); <span class="comment">// 是否已经attachToWindow</span></div><div class="line">        TextView textView = <span class="keyword">new</span> TextView(mActivityController.get());</div><div class="line">        view.addView(textView);</div><div class="line">        Assert.assertTrue(shadow.didRequestLayout());   <span class="comment">// 是否调用了requestLayout</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testButton</span><span class="params">()</span> </span>&#123;</div><div class="line">        Button btn = (Button) mActivityController.get().findViewById(R.id.button);</div><div class="line">        Assert.assertNotNull(btn);</div><div class="line">        btn.performClick();</div><div class="line">        ShadowActivity shadowActivity = Shadows.shadowOf(mActivityController.get());</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(mActivityController.get(), SecondActivity.class);</div><div class="line">        Assert.assertEquals(shadowActivity.getNextStartedActivity().getComponent(), intent.getComponent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有几点注意：</p><ul><li>使用<code>@RunWith(RobolectricGradleTestRunner.class)</code>时需要指定<code>@Config(constants = BuildConfig.class)</code>，它会从<code>/build/intermediates/</code>目录下找到merge的Manifest、Resource、Asset目录并加载。如果使用<code>@RunWith(RobolectricTestRunner.class)</code>则需要手动指定<code>@Config(manifest = &quot;...&quot;, resourceDir = &quot;...&quot;, assetDir = &quot;...&quot;)</code>，<code>manifest</code>设置的目录base于Unit Test Config里面的”Working Directory”（见下图）</li></ul><p><img src="/image/robo-config.png" alt="robo-config"></p><p>其他值<code>resourceDir</code>、<code>assetDir</code>的目录Base于<code>manifest</code>的父目录。</p><ul><li><p><code>visible()</code> 可能会令你感到困惑，因为它不属于<code>Activity</code>生命周期之一，但是执行<code>visibile()</code>会保证Activity的到Window上（包括初始化DecorView + add到WindowManager），否则<code>findViewById()</code>、<code>attachToWindow</code>等都会有问题。</p></li><li><p>关于MultiDex</p></li></ul><p>Robolectric是在JVM上运行代码，根本没有”MultiDex”这回事，如果你的项目里用到了它，需要额外加入一个依赖:</p><p><code>testCompile &quot;org.robolectric:shadows-multidex:${robolectricVersion}&quot;</code></p><p>它hook了<code>MultiDex</code>这个类，让它在<code>install</code>的时候啥也不干。</p><h3 id="2-进阶使用：各类Shadow"><a href="#2-进阶使用：各类Shadow" class="headerlink" title="2. 进阶使用：各类Shadow"></a>2. 进阶使用：各类Shadow</h3><p>Shadow是Robolectric里面的Hook类前缀，你可以利用Shadow得到一些Android组件无法获取到的状态，因为有的属性没有变量维护/没有public getter，又或无法获取上次操作结果，这时候就可以使用Shadow来定制一些需要的属性保存，看下面这个例子：</p><p>你的Activity里面有一个View(R.id.view), 它将<code>OnClickListener</code>设置为了<code>Activity</code>自身，在点击时会发一个广播(action=”com.desmond.androidtest.TestBroadcast”)，我们想验证这个情况。但是有两个问题：</p><ul><li>View无法获取到<code>OnClickListener</code>，只能知道<code>hasOnClickListener()</code>；</li><li>Receiver不是你定义的，你只负责发，你如果需要验证需要自己额外注册一个Receiver，并编译运行检查是否成功。</li></ul><p>使用Robolectric，你可以写下这么一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(RobolectricGradleTestRunner.class)</div><div class="line"><span class="meta">@Config</span>(constants = BuildConfig.class, sdk = <span class="number">21</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityTest</span> </span>&#123;</div><div class="line">    ActivityController&lt;MainActivity&gt; mActivityController;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</div><div class="line">        mActivityController = Robolectric.buildActivity(MainActivity.class).create().start().resume().visible();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBase</span><span class="params">()</span> </span>&#123;</div><div class="line">        View view = mActivityController.get().findViewById(R.id.view);</div><div class="line">        Assert.assertNotNull(view);                     <span class="comment">// 是否存在view</span></div><div class="line">        ShadowView shadow = Shadows.shadowOf(view);</div><div class="line">        Assert.assertEquals(shadow.getOnClickListener(), mActivityController.get()); <span class="comment">// 是否已经attachToWindow</span></div><div class="line">        view.performClick();</div><div class="line">        ShadowActivity shadowActivity = Shadows.shadowOf(mActivityController.get());</div><div class="line">        Intent expectedIntent = <span class="keyword">new</span> Intent(<span class="string">"com.desmond.androidtest.TestBroadcast"</span>);</div><div class="line">        List&lt;Intent&gt; intentList = shadowActivity.getBroadcastIntents();  <span class="comment">// 获取发出的Broadcast</span></div><div class="line">        <span class="keyword">boolean</span> hasIntentSend = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (Intent i : intentList) &#123;</div><div class="line">            <span class="keyword">if</span>(i.getAction().equals(expectedIntent.getAction())) &#123;</div><div class="line">                hasIntentSend = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Assert.assertTrue(hasIntentSend);  <span class="comment">// 是否发出指定Broadcast</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>很有意思吧，更多的”Shadow”可以在<code>Shadows</code>这个类里面找着，用的时候直接<code>Shadows.shadowOf(object)</code>就可以返回对应<code>Shadow</code>实例。你还可以<a href="http://robolectric.org/custom-shadows/" target="_blank" rel="external">自定义Shadow</a>来完成你需要的测试功能点。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Android/" rel="tag"># Android</a> <a href="/tags/TDD/" rel="tag"># TDD</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/rn-bridge/" rel="next" title="【React Native for Android】jsBridge实现原理"><i class="fa fa-chevron-left"></i> 【React Native for Android】jsBridge实现原理</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/fake-server/" rel="prev" title="如何在开发过程中搭建简单的假数据服务器">如何在开发过程中搭建简单的假数据服务器 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Desmond Yao</p><p class="site-description motion-element" itemprop="description">Android developer.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/desmond1121" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://weibo.com/u/1901104743" target="_blank" title="Weibo"><i class="fa fa-fw fa-globe"></i>Weibo</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://kaedea.com/" title="Kaedea" target="_blank">Kaedea</a></li><li class="links-of-blogroll-item"><a href="http://yrom.net/" title="Yrom" target="_blank">Yrom</a></li><li class="links-of-blogroll-item"><a href="http://blog.zhaiyifan.cn/" title="MarkZhai" target="_blank">MarkZhai</a></li><li class="links-of-blogroll-item"><a href="http://abner-nimengbo.cn/" title="泥阿布" target="_blank">泥阿布</a></li><li class="links-of-blogroll-item"><a href="https://xiequan.info" title="谢权" target="_blank">谢权</a></li><li class="links-of-blogroll-item"><a href="http://rarnu.com/" title="何老师" target="_blank">何老师</a></li><li class="links-of-blogroll-item"><a href="http://fucknmb.com/" title="区长" target="_blank">区长</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要单元测试？"><span class="nav-number">1.</span> <span class="nav-text">为什么要单元测试？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mockito的作用"><span class="nav-number">2.</span> <span class="nav-text">Mockito的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Mock-模拟行为"><span class="nav-number">2.1.</span> <span class="nav-text">1. Mock 模拟行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-验证行为"><span class="nav-number">2.2.</span> <span class="nav-text">2. 验证行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-题外话"><span class="nav-number">2.3.</span> <span class="nav-text">3. 题外话</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-MockHandlerImpl中处理函数调用："><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1 MockHandlerImpl中处理函数调用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-OugoingStubbingImpl中添加Stub"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.2 OugoingStubbingImpl中添加Stub</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Roboletric能做的事"><span class="nav-number">3.</span> <span class="nav-text">Roboletric能做的事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-基础用法"><span class="nav-number">3.1.</span> <span class="nav-text">1. 基础用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-进阶使用：各类Shadow"><span class="nav-number">3.2.</span> <span class="nav-text">2. 进阶使用：各类Shadow</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Desmond Yao</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script></body></html>