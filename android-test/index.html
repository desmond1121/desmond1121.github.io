<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/luffy.img?v=5.1.3"><link rel="mask-icon" href="/images/luffy.img?v=5.1.3" color="#222"><meta name="keywords" content="Android Test,TDD,"><meta name="description" content="本文介绍测试驱动开发(Test-Driven development)的流程与精要，还有在Java、Android上的测试手段。"><meta name="keywords" content="Android Test,TDD"><meta property="og:type" content="article"><meta property="og:title" content="Android测试驱动开发(TDD)"><meta property="og:url" content="http://blog.desmondyao.com/android-test/index.html"><meta property="og:site_name" content="Desmond&#39;s Blog"><meta property="og:description" content="本文介绍测试驱动开发(Test-Driven development)的流程与精要，还有在Java、Android上的测试手段。"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.desmondyao.com/image/test/tdd-magento.gif"><meta property="og:image" content="http://blog.desmondyao.com/image/test/AndroidTest.png"><meta property="og:updated_time" content="2017-11-06T12:30:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Android测试驱动开发(TDD)"><meta name="twitter:description" content="本文介绍测试驱动开发(Test-Driven development)的流程与精要，还有在Java、Android上的测试手段。"><meta name="twitter:image" content="http://blog.desmondyao.com/image/test/tdd-magento.gif"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.desmondyao.com/android-test/"><title>Android测试驱动开发(TDD) | Desmond's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Desmond's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Focus on Java, Android, React Native.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.desmondyao.com/android-test/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Desmond Yao"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Desmond's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Android测试驱动开发(TDD)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-06T17:45:01+08:00">2016-08-06</time></span></div></header><div class="post-body" itemprop="articleBody"><p>本文介绍测试驱动开发(Test-Driven development)的流程与精要，还有在Java、Android上的测试手段。<br><a id="more"></a></p><h2 id="什么是TDD？"><a href="#什么是TDD？" class="headerlink" title=" 什么是TDD？"></a><a href="intro"></a> 什么是TDD？</h2><p>测试驱动开发(TDD)是由敏捷开发派生而来，它描述的是这样一种开发流程：</p><p><img src="/image/test/tdd-magento.gif" alt="tdd"></p><p>图片来自<a href="https://firebearstudio.com/blog/tag/test-driven-development" target="_blank" rel="external">FirebaseStudio</a></p><h3 id="1-添加测试用例"><a href="#1-添加测试用例" class="headerlink" title="1. 添加测试用例"></a>1. 添加测试用例</h3><p><strong>每一个</strong>功能点的添加，开发者都必须对它进行详细地分析，然后快速地、有针对地书写测试代码。它和正常的开发流程不同的是，开发者需要在<strong>开发每一个功能点之前</strong>，仔细想清楚需求，先用测试用例描述出功能点的<strong>需求</strong>与<strong>异常情况</strong>。</p><p>这要求我们遵循一定的设计原则，<strong>先设计出接口行为，添加空的实现</strong>，然后将测试用例快速写出来。</p><h3 id="2-测试不通过"><a href="#2-测试不通过" class="headerlink" title="2. 测试不通过"></a>2. 测试不通过</h3><p>此时我们需要跑一遍测试，我们没有写任何功能的代码之前，<strong>新增的测试用例</strong>肯定会<strong>失败</strong> ，因为我们没有实现功能细节。</p><h3 id="3-添加代码"><a href="#3-添加代码" class="headerlink" title="3. 添加代码"></a>3. 添加代码</h3><p>针对我们写下的测试用例，完善代码。注意，在此阶段，你的<strong>所有目标</strong>就是让代码通过步骤一加入的测试用例。你<strong>不应该</strong>添加跟步骤一所加入的测试中无关的代码。</p><h3 id="4-重复动作"><a href="#4-重复动作" class="headerlink" title="4. 重复动作"></a>4. 重复动作</h3><p>当所有的测试用例都能运行通过时，你若要应该再增加、改变功能，必须从步骤1开始重新进行。</p><h3 id="5-代码优化"><a href="#5-代码优化" class="headerlink" title="5. 代码优化"></a>5. 代码优化</h3><p>由于你在步骤3中是面向测试用例编程，所以可能会导致代码风格、结构有不妥当的地方。此时你应该重新审视一遍自己的代码，如果有不适的地方（如重复功能的类、语义不详的名称、混乱的工程结构等），你应该对其进行一定的重构。然后你需要重复运行写好的测试用例，测试通过让你对自己的改动具有信心。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>TDD的作用已经不仅仅局限于”测试“，它为软件开发流程提供了一个新的思路：先写测试，用测试衡量代码。我参考了很多国内的资料，却没有发现一个比较好的将TDD应用在工程中的例子。这其中有很多原因，你可以找出很多很多理由来不写测试（UI测试不好写、产品需求容易改、维护麻烦等等），但是不可否认的是TDD提供的理念是有一定借鉴意义的。</p><p>我先将测试技术做一个系统的介绍，后面再来谈一些TDD的“哲学”。</p><h2 id="Java单元测试简介"><a href="#Java单元测试简介" class="headerlink" title=" Java单元测试简介"></a><a href="unit-test"></a> Java单元测试简介</h2><p>单元测试是指对软件中的最小可测试单元进行检查和验证，它满足：</p><ul><li><strong>一致性</strong> 重复运行相同单元测试的结果一致。</li><li><strong>隔离性</strong> 单元测试只在一个小模块内进行，不与其他模块交互，也不影响其他单元测试。</li></ul><p>单元测试主要的工作就是<strong>验证行为的结果</strong>。这个概念跟上文中说的<strong>触发动作</strong>和<strong>期望结果</strong>是一致的。下面先介绍一些技术与术语：</p><h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p>JUnit是一个Java的Unit测试库。它提供了一套比较成熟的单元测试解决方案，每个测试类里面有多个测试用例，并提供了用例前后的Hook、Rule等方便测试。值得一提的是JUnit3、4的区别非常大，在4.x中引入了大量的改进，我们可以用两段代码来感受一下：</p><p><em>JUnit3的测试代码</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit3Test</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//在每个测试方法执行之前要调用的代码</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//在每个测试方法结束后执行的代码</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCase1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//所有测试用例需要用test开头</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果期望一个测试用例内产生指定异常，只能这么写。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testException</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            doSomething();</div><div class="line">            fail();</div><div class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</div><div class="line">            Assert.assertTrue(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><em>JUnit4的测试代码，有很多语法改进，并可以方便地设置期望Exception，并且有很多JUnit3无法做到的(Rule, Before/AfterClass, Timeout, static import)</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit4Test</span> </span>&#123;</div><div class="line">    <span class="meta">@Rule</span></div><div class="line">    <span class="keyword">public</span> TemporaryFolder mFolder</div><div class="line">        = <span class="keyword">new</span> TemporaryFolder();  <span class="comment">//在每个测试方法执行前建立临时文件，结束后删除它。</span></div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//同JUnit3中setup</span></div><div class="line"></div><div class="line">    <span class="meta">@After</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//同JUnit3中的teardown</span></div><div class="line"></div><div class="line">    <span class="meta">@BeforeClass</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span> </span>&#123; <span class="comment">//在该类第一个测试方法执行前被调用，只会调用一次。</span></div><div class="line">        PowerMockito.mockStatic(ForMock.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@AfterClass</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//在该类第一个测试方法执行后被调用，只会调用一次。</span></div><div class="line"></div><div class="line">    <span class="meta">@Test</span>(expected = NullPointerException.class,</div><div class="line">         timeout = <span class="number">200</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExceptionAndTimeout</span><span class="params">()</span> </span>&#123; <span class="comment">//所有测试类使用@Test注解</span></div><div class="line">        doSomething();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><p>Mock是测试中非常经常使用到的一个术语，它的作用就如字面意思：“虚拟对象”。它有很多方面的作用，特别是在测试上。我们之前所说，测试就是需要列举出“触发动作”和验证”期望结果”。那么现在有两个问题：</p><ol><li>通常我们在设计代码的时候，不会去保留操作结果，这会给程序带来非常多冗余的变量、代码逻辑。</li><li>触发动作经常是有一定上下文、环境依赖的，测试中难以模拟出这个情况。</li></ol><p>为了应对这样的窘境，各种各样的Mock开源库出现了，举两个用得最多的例子：</p><ul><li><a href="http://mockito.org" target="_blank" rel="external">Mockito</a> 是一个开源的Mock库。提供了创建虚拟类(Mock)、局部扩展(Spy)、验证调用行为(Verify)的API。</li><li><a href="https://github.com/jayway/powermock" target="_blank" rel="external">PowerMock</a> 是针对上述Mockito的拓展。它通过自定义的<code>ClassLoader</code>，能够达到它们无法做到的一些事情：针对静态类、final类、private方法的Mock与Verify。</li></ul><p>这里需要注意，使用Mock之前应该仔细思考它的必要性，如果你花很多时间、大量代码来生成Mock、验证Mock对象的行为，这可能就偏离了测试的初衷，走入了“为测试而测试”的陷阱。你可能就要思考，为什么你的代码需要这么多Mock才能够被单元测试，会不会写的耦合度太高了？</p><p>好，言归正传，我们来简单看一下它们用法。想象这么一个场景，你的操作需要依赖时间，你要检查日期的改变、时间的流逝等相关的事情，那么你如果手工测试就非常尴尬，花费不必要的时间在等待时间上，而用PowerMock，你可以做到改变时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</div><div class="line"><span class="meta">@PrepareForTest</span>(&#123;System.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeUtilsTest</span> </span>&#123;</div><div class="line">  <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">    Random random = <span class="keyword">new</span> Random(RANDOM_SEED);</div><div class="line"></div><div class="line">    PowerMockito.mockStatic(System.class);</div><div class="line">    when(System.currentTimeMillis()).thenReturn(<span class="number">0l</span>); <span class="comment">//直接将System.currentTimeMillis设置为0.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于Mockito的更多用法，可以参考我另一篇文章<a href="http://blog.desmondyao.com/mockito-robolectric-test/">使用Mockito和Roboletric进行Android单元测试</a>。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>Assert，是单元测试中非常重要的环节之一。它是用于校验输出结果与期望结果的语法。最原始的Assert语法就是一个assert关键字后面跟个布尔值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">assert</span> actual == expected;</div></pre></td></tr></table></figure><p>后来大家发现这样太不好使了，于是JUnit对它做了一些封装:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 8大基础类型/String/利用Object.equals()进行的Equals/NotEquals判断</span></div><div class="line">Assert.assertEquals(expected, actual);</div><div class="line">Assert.assertNotEquals(expected, actual);</div><div class="line"></div><div class="line"><span class="comment">// String/Object的相同实例判断</span></div><div class="line">Assert.assertSame(expected, actual);</div><div class="line">Assert.assertNotSame(expected, actual);</div><div class="line"></div><div class="line"><span class="comment">// 8大基础类型/String/Object的数组相同判断</span></div><div class="line">Assert.assertArrayEquals(expectedArray, actualArray);</div></pre></td></tr></table></figure><p>由于JUnit原生的Assert还是不够强大，只能判断等于、不等于的情况，它实际上只提供了很基础的相同值/实例的判断，这样代码可读性、易用性就会收到影响。所以各类开源库出现，对它进行了封装：</p><ul><li><a href="http://hamcrest.org/JavaHamcrest/" target="_blank" rel="external">Hamcrest</a> 是一个开源的Assert语法拓展库，它提供了方便、强大的情景<strong>匹配</strong>API，不仅支持Java，也支持其他多种语言。</li><li><a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="external">AssertJ</a> 是另一个开源的Assert语法的拓展库，它提供了各类方便的情景检查与链式调用的语法糖，易于拓展，用起来非常舒服。</li><li><a href="https://github.com/square/assertj-android" target="_blank" rel="external">AssertJ-Android</a> 是Square针对AssertJ的一个拓展，提供了对Android各类控件的情景检查。</li></ul><p>AssertJ与Hamcrest对于Assert的功能加强上区别不是很大，他们都提供了非常强大的情景Matcher，只不过两者的编程方式不太一样。你看段代码感受一下就知道了：</p><p><em>Hamcrest</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.*;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHamcrest</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    strings.add(<span class="string">"test"</span>);</div><div class="line">    MatcherAssert.assertThat(strings, not(empty()));</div><div class="line">    MatcherAssert.assertThat(strings, contains(<span class="string">"test"</span>));</div><div class="line">    MatcherAssert.assertThat(strings, hasSize(<span class="number">1</span>));</div><div class="line">    MatcherAssert.assertThat(strings, is(instanceOf(ArrayList.class)));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>Hamcrest的断言方式就是<code>assertThat(something, condition)</code>，我们看看AssertJ：</p><p><em>AssertJ</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAssertJ</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    strings.add(<span class="string">"test"</span>);</div><div class="line">    Assertions.assertThat(strings)</div><div class="line">        .isInstanceOf(ArrayList.class)</div><div class="line">        .isNotEmpty()</div><div class="line">        .contains(<span class="string">"test"</span>, Index.atIndex(<span class="number">0</span>))</div><div class="line">        .hasSize(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>AssertJ写起来也很舒服，但是优越之处就是它<strong>封装了更多基础类型的使用</strong>，这是Hamcrest没有的，可以说使用起来更简单。</p><h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><p><strong>覆盖率(Coverage)</strong> 即跑一遍单元测试，统计覆盖到的各类代码的指标。简单来说有这么几种：</p><ul><li><strong>函数覆盖率</strong> 一个类里面被单元测试调用到的函数在它所有函数中的占比。</li><li><strong>语句覆盖率</strong>、<strong>分支覆盖率</strong> 一个类中，单元测试所覆盖的语句、分支在这个类的语句、分支中的占比。举个例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span>(a &gt; b) &#123;</div><div class="line">    result = a;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b) &#123;</div><div class="line">    result = b;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == b) &#123;</div><div class="line">    result = -<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试代码</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</div><div class="line">  Assert.assertEquals(func(<span class="number">1</span>, <span class="number">0</span>), <span class="number">1</span>);</div><div class="line">  Assert.assertEquals(func(<span class="number">1</span>, <span class="number">1</span>), -<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码中我们只测试了(a &gt; b) 和 (a = b)的情况，那么(a &lt; b)这个if分支就没有走，并且它涉及到的语句也没有走。即它们没有被覆盖。</p><p>Java导出测试覆盖率的工具使用最多的是<a href="https://github.com/jacoco/jacoco" target="_blank" rel="external">Jacoco</a>, Intelij Idea(Android Studio)与Eclipse都有相应的工具。在Eclipse上可以用<a href="http://www.eclemma.org/index.html" target="_blank" rel="external">Eclmma</a>，而Intellij Idea已经将它内置为IDE的一部分。</p><p>值得一提的是AndroidTest无法直接用工具测试覆盖率，不过它的gradle插件内置了Jacoco。对于<a href="#android">AndroidTest</a>覆盖率，可以通过在<code>build.gradle</code>中添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">   buildTypes &#123;</div><div class="line">      debug &#123;</div><div class="line">         testCoverageEnabled = <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后运行命令行<code>./gradlew createDebugCoverageReport</code>即可导出report到<code>build/report</code>路径下。</p><p>最后，<strong>覆盖率其实有的时候不能说明什么</strong>，测试覆盖率高的代码不一定就是很稳定的代码，这点肯定要清楚。写了很多测试，调用了很多工程代码，最后可能然并卵。但是有一点是认可的，<strong>未覆盖率</strong> 能帮助你对代码的回归思考：</p><blockquote><p>如果你写测试都不测这个函数，那它会不会有问题？那它是不是真的会用到？</p></blockquote><p>如果真的打算写测试，它是可以帮助你思考的一个指标。</p><h2 id="Android-测试概览"><a href="#Android-测试概览" class="headerlink" title=" Android 测试概览"></a><a href="android"></a> Android 测试概览</h2><p>在Android上的测试技术总的来说可以分为两种：</p><ul><li><strong>本地测试(Local Unit test)</strong> 跑在JVM上的单元测试，在<code>/src/test/java</code>下的代码。、配合<a href="https://github.com/robolectric/robolectric" target="_blank" rel="external">Robolectric</a>也可以跑部分Android相关的代码测试。容易书写，容易运行。</li><li><strong>Instrument 测试</strong> 跑在Android设备上的测试，在<code>/src/androidTest/java</code>下的代码。默认使用junit3的写法，使用<code>AndroidJUnit4</code>可以使用junit4的单元测试（这也是官方推荐的做法）。(之间区别可以参考<a href="http://www.asjava.com/junit/junit-3-vs-junit-4-comparison/" target="_blank" rel="external">junit3 vs junit4</a>)。</li></ul><p>可以简单用一张图来总结：</p><p><img src="/image/test/AndroidTest.png" alt="AndroidTest"></p><p>那来说说它们的各类应用场景吧。</p><h3 id="Roboletric"><a href="#Roboletric" class="headerlink" title="Roboletric"></a>Roboletric</h3><p><a href="https://github.com/robolectric/robolectric" target="_blank" rel="external">roboletric</a>的出现让一些仅跟UI交互的Android代码变得非常容易测试，它能够让一些仅依赖UI、对于Android设备环境没有强需求的模块（GPS、电池状态、跨App请求等）能够直接<strong>在JVM上跑起部分Android相关的测试代码</strong>。</p><p>它的用法可以参考<a href="http://blog.desmondyao.com/mockito-robolectric-test/">使用Mockito和Roboletric进行Android单元测试</a>。</p><p>值得一提的是，Robolectric同样也用到了自定义ClassLoader，配合PowerMock使用时需要参考<a href="https://github.com/robolectric/robolectric/wiki/Using-PowerMock" target="_blank" rel="external">Wiki</a>。</p><h3 id="Android-Instrument-测试"><a href="#Android-Instrument-测试" class="headerlink" title="Android Instrument 测试"></a>Android Instrument 测试</h3><p>Instrument测试是在Android设备上跑的测试，它运行在与目标App同一个进程中。它能够为你提供各类Android设备、运行时、多应用交互相关的API，这是Local Unit测试无法比拟和提供的。主要的测试手段是<a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html" target="_blank" rel="external">Espresso</a>和<a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html" target="_blank" rel="external">UIAutomator</a>。</p><p>注意：它默认只支持JUnit3的写法，通过Support库可以支持JUnit4. 通过添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  androidTestCompile &apos;com.android.support.test:runner:0.4&apos;</div><div class="line">  androidTestCompile &apos;com.android.support.test:rules:0.4&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同时在Gradle里面指定用JUnitRunner运行Instrument:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">  defaultConfig &#123;</div><div class="line">    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后在你要测试的类上加<code>@RunWith(AndroidJUnit4.class)</code>注解，即可使用JUnit4的功能。</p><h4 id="AndroidJUnit4"><a href="#AndroidJUnit4" class="headerlink" title="AndroidJUnit4"></a>AndroidJUnit4</h4><p>引入JUnit4不仅让你能够使用它的一些优点，同时能享受一些引入的rule：</p><ul><li><code>ActivityTestRule&lt;Activity.class&gt;</code> 这个Rule能在你的测试方法运行前启动指定Activity，然后在测试方法结束后将Activity手动finish掉，主要是保证了Activity的启动与<strong>不影响其他测试</strong>。</li><li><code>ServiceTestRule</code> 在测试中通过它启动的Service能够保证在测试方法运行时Service被启动or绑定，并且在测试方法结束后将Service解绑or销毁。</li><li><code>UiThreadTestRule</code> 可以让你在任何时候使用<code>mRule.runOnUIThread()</code>在UI线程上运行任务。</li></ul><h4 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h4><p>Espresso是在Instrument测试提供了强大的<strong>UI测试</strong>框架的库，它能够做到：</p><ol><li>UI控件的查找匹配；</li><li>各类动作的触发与校验；</li><li>Intent的检测与模拟。</li></ol><p>你只需要额外引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">androidTestCompile &apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;</div></pre></td></tr></table></figure><p>即可使用Espresso.</p><p>具体的使用方法可以参考<a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html" target="_blank" rel="external">Android官网</a>。</p><h4 id="Espresso-vs-Robolectric"><a href="#Espresso-vs-Robolectric" class="headerlink" title="Espresso vs Robolectric"></a>Espresso vs Robolectric</h4><p>大致的一看，Robolectric的功能和Espresso的功能区别不太大，那么我们应该如何选择两个测试框架呢？</p><p>Robolectric比Espresso的好用之处就是两点：</p><ol><li>无需实机测试，JVM上就能跑；</li><li>集成CI自动化测试很方便；</li></ol><p>相应的，也有一些缺点：</p><ol><li>无法覆盖实机功能关联的API（相机、GPS、Activity之间交互）；</li><li>不是实机环境，Mock太多，做除UI外的太复杂的测试时不能令人信服。</li></ol><p>我认为在你在做一些纯UI测试、对Android运行时环境要求不高的时候，可以使用Robolectric，这时候它很好用，也很好写。但是其他情况时最好使用Espresso，它更加值得信赖。</p><h4 id="UIAutomator"><a href="#UIAutomator" class="headerlink" title="UIAutomator"></a>UIAutomator</h4><p>它同样也是用于UI测试的框架，但是不同于Espresso的是，它的目的主要是App与设备、触屏动作（拖动滑动）、其他应用之间的交互。</p><p>我们可以通过添加如下依赖来使用UIAutomator：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">androidTestCompile &apos;com.android.support.test.uiautomator:uiautomator-v18:2.1.1&apos;</div></pre></td></tr></table></figure><p>具体的使用方法可以参考<a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html#setup" target="_blank" rel="external">Android官网</a>。</p><h2 id="TDD的基本原则"><a href="#TDD的基本原则" class="headerlink" title="TDD的基本原则"></a><a href="discipline"></a>TDD的基本原则</h2><p><strong>完善测试开发流程比测试技术本身要重要很多倍。</strong></p><p>在由产品主导业务功能、项目迭代周期快、强大的手工QA团队的现状下，程序员自己写测试用例的必要性还有吗？答案是肯定有的。团队中肯定有写一些类库、公共组件，这些库往往是纯JAVA（如字符串、文件IO、线程库）或Android的sdk（网络、下载、账号、图片加载）等。它们与业务、UI关系不大，在界面上又很难以有所体现，手工QA团队很难验证。我相信在这时候，一个基于TDD的开发流程是会有一些帮助的。单元测试的通过让你有信心将这些库的改动引入到项目中。</p><p>在下面的介绍中，你会发现测试代码都是非常容易去写的，开源界也涌出了各类测试框架方便开发者写测试用例。但是在开始写测试用例之前，需要 <strong>想清楚为什么要做测试</strong>。你可能不需要完全遵守TDD的流程，但是如果仅仅注重测试环节，而不思考更深层次的意义，可能导致：</p><ul><li>代码很难被测试；</li><li>仅仅为了写测试而写测试，测试效果不大；</li><li>测试通过了，仍然有问题！</li><li>测试覆盖度很高，但是代码质量依然很低。</li></ul><p>在这个过程中，你会发现TDD是非常有工程学上的借鉴意义的。我认为TDD的几个核心原则就是：</p><h3 id="分析-amp-先写测试"><a href="#分析-amp-先写测试" class="headerlink" title="分析&amp;先写测试"></a>分析&amp;先写测试</h3><p>你需要对新增的功能点进行系统分析，拆分每个功能点里面的正常、异常情况。每一个功能点，都应该是有一个或多个对应的<strong>触发动作</strong>和<strong>期望结果</strong>的。如果你连触发改动的动作与期望结果都无法准确地描述出来，那么只能说明你不熟悉新增的功能，或者这个功能点不完善。在系统分析之后，写下测试用例。</p><h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h3><p>很多人看到“先写测试”这一点的时候，都很难去想象如何在没有实现细节的时候去写测试。“我都没有代码，如何写测试？”，这可能是最直观的感受。<br>当然，完全不写代码，就写测试用例是不可能的。但是在只声明接口行为，<strong>不写具体实现</strong>，此时去写测试用例，是很容易做到的。这时候<a href="http://blog.csdn.net/zhengzhb/article/details/7289269" target="_blank" rel="external">依赖倒置原则</a>就有比较大的用武之地，你的功能应该依赖上层接口，这样很容易造出一个空实现的架子，用于测试用例。</p><h3 id="快速写测试、运行测试"><a href="#快速写测试、运行测试" class="headerlink" title="快速写测试、运行测试"></a>快速写测试、运行测试</h3><p>市面上有五花八门的测试技术与框架，各类的mock横行霸道。但是我们应该注意一点：<strong>我们写的测试不能是脆弱、编写成本高的</strong>。如果某个功能点，我们辛辛苦苦写了很多测试，但是下一个版本迭代，所有的测试用例都被推翻，那么我们可能就要考虑测试的必要性或者是不是测试的方法不对了。或者如果测试非常难写（相对于手工测试来说）、测试点是不可重复运行的，那都可以考虑不写测试。</p><p>关于项目与工程的应用上，更多还是应该结合项目自身来适应。</p><p>在此特别推荐一个博客系列：<a href="http://blog.karumi.com/world-class-testing-development-pipeline-for-android/" target="_blank" rel="external">World-Class Testing Development Pipeline for Android</a>。讲述了<a href="http://www.karumi.com/" target="_blank" rel="external">Karumi</a>团队在做Android 自动化测试时候的一些思考与碰到的问题，如果你希望写好测试用例，十分建议一读。</p><blockquote><p>英语不好的同学可以读<a href="http://blog.zhaiyifan.cn/2016/02/23/world-class-testing-development-pipeline-for-android-part-1/" target="_blank" rel="external">Mark大神的翻译</a>。</p></blockquote><p>参考文章：</p><ul><li>github - googlesamples/android-testing: <a href="https://github.com/googlesamples/android-testing" target="_blank" rel="external">https://github.com/googlesamples/android-testing</a></li><li>Android Test Support Library: <a href="https://google.github.io/android-testing-support-library/" target="_blank" rel="external">https://google.github.io/android-testing-support-library/</a></li><li>Using Hamcrest for testing: <a href="http://www.vogella.com/tutorials/Hamcrest/article.html" target="_blank" rel="external">http://www.vogella.com/tutorials/Hamcrest/article.html</a></li><li>Test Driven Development: <a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="external">https://en.wikipedia.org/wiki/Test-driven_development</a></li><li>World-Class Testing Development Pipeline for Android: <a href="http://blog.karumi.com/world-class-testing-development-pipeline-for-android/" target="_blank" rel="external">http://blog.karumi.com/world-class-testing-development-pipeline-for-android/</a></li><li>Test-Driven Development in Microsoft .NET <a href="https://ptgmedia.pearsoncmg.com/images/9780735619487/samplepages/9780735619487.pdf" target="_blank" rel="external">https://ptgmedia.pearsoncmg.com/images/9780735619487/samplepages/9780735619487.pdf</a></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Android-Test/" rel="tag"># Android Test</a> <a href="/tags/TDD/" rel="tag"># TDD</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/fake-server/" rel="next" title="如何在开发过程中搭建简单的假数据服务器"><i class="fa fa-chevron-left"></i> 如何在开发过程中搭建简单的假数据服务器</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/android-show-time/" rel="prev" title="Activity到底是什么时候显示到屏幕上的呢？">Activity到底是什么时候显示到屏幕上的呢？ <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Desmond Yao</p><p class="site-description motion-element" itemprop="description">Android developer.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是TDD？"><span class="nav-number">1.</span> <span class="nav-text">什么是TDD？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-添加测试用例"><span class="nav-number">1.1.</span> <span class="nav-text">1. 添加测试用例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-测试不通过"><span class="nav-number">1.2.</span> <span class="nav-text">2. 测试不通过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-添加代码"><span class="nav-number">1.3.</span> <span class="nav-text">3. 添加代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-重复动作"><span class="nav-number">1.4.</span> <span class="nav-text">4. 重复动作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-代码优化"><span class="nav-number">1.5.</span> <span class="nav-text">5. 代码优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解"><span class="nav-number">1.6.</span> <span class="nav-text">理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java单元测试简介"><span class="nav-number">2.</span> <span class="nav-text">Java单元测试简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JUnit"><span class="nav-number">2.1.</span> <span class="nav-text">JUnit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mock"><span class="nav-number">2.2.</span> <span class="nav-text">Mock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#断言"><span class="nav-number">2.3.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖率"><span class="nav-number">2.4.</span> <span class="nav-text">覆盖率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-测试概览"><span class="nav-number">3.</span> <span class="nav-text">Android 测试概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Roboletric"><span class="nav-number">3.1.</span> <span class="nav-text">Roboletric</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Instrument-测试"><span class="nav-number">3.2.</span> <span class="nav-text">Android Instrument 测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AndroidJUnit4"><span class="nav-number">3.2.1.</span> <span class="nav-text">AndroidJUnit4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Espresso"><span class="nav-number">3.2.2.</span> <span class="nav-text">Espresso</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Espresso-vs-Robolectric"><span class="nav-number">3.2.3.</span> <span class="nav-text">Espresso vs Robolectric</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UIAutomator"><span class="nav-number">3.2.4.</span> <span class="nav-text">UIAutomator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TDD的基本原则"><span class="nav-number">4.</span> <span class="nav-text">TDD的基本原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分析-amp-先写测试"><span class="nav-number">4.1.</span> <span class="nav-text">分析&先写测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖倒置原则（DIP）"><span class="nav-number">4.2.</span> <span class="nav-text">依赖倒置原则（DIP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速写测试、运行测试"><span class="nav-number">4.3.</span> <span class="nav-text">快速写测试、运行测试</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Desmond Yao</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script></body></html>