<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/luffy.img?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/luffy.img?v=5.1.3"><link rel="mask-icon" href="/images/luffy.img?v=5.1.3" color="#222"><meta name="keywords" content="Android,React Native,"><meta name="description" content="本文基于源码：0.40.0最近把yoga源码看了一遍，它是一个按照Flexbox规范，利用Web熟悉的API做高效measure的库。本来想做个它在React Native for Android (以下简称RN4A)中的应用与分析，但是在这之前应该先将RN渲染流程搞懂，我们才能去进一步分析如何应用yoga去辅助测量。"><meta name="keywords" content="Android,React Native"><meta property="og:type" content="article"><meta property="og:title" content="React Native 核心渲染流程分析(1) - 初识组件系统"><meta property="og:url" content="http://blog.desmondyao.com/rn-render-1/index.html"><meta property="og:site_name" content="Desmond&#39;s Blog"><meta property="og:description" content="本文基于源码：0.40.0最近把yoga源码看了一遍，它是一个按照Flexbox规范，利用Web熟悉的API做高效measure的库。本来想做个它在React Native for Android (以下简称RN4A)中的应用与分析，但是在这之前应该先将RN渲染流程搞懂，我们才能去进一步分析如何应用yoga去辅助测量。"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.desmondyao.com/image/rn/rn-render-start.png"><meta property="og:image" content="http://blog.desmondyao.com/image/rn/rn-render-instantiate.png"><meta property="og:image" content="http://blog.desmondyao.com/image/rn/rn-render-composite.jpeg"><meta property="og:image" content="http://blog.desmondyao.com/image/rn/rn-render-rnbase.jpeg"><meta property="og:updated_time" content="2017-11-06T12:30:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="React Native 核心渲染流程分析(1) - 初识组件系统"><meta name="twitter:description" content="本文基于源码：0.40.0最近把yoga源码看了一遍，它是一个按照Flexbox规范，利用Web熟悉的API做高效measure的库。本来想做个它在React Native for Android (以下简称RN4A)中的应用与分析，但是在这之前应该先将RN渲染流程搞懂，我们才能去进一步分析如何应用yoga去辅助测量。"><meta name="twitter:image" content="http://blog.desmondyao.com/image/rn/rn-render-start.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.desmondyao.com/rn-render-1/"><title>React Native 核心渲染流程分析(1) - 初识组件系统 | Desmond's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Desmond's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Focus on Java, Android, React Native.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.desmondyao.com/rn-render-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Desmond Yao"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Desmond's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">React Native 核心渲染流程分析(1) - 初识组件系统</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-08T13:48:03+08:00">2017-01-08</time></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>本文基于源码：<a href="https://github.com/facebook/react-native/releases/tag/v0.40.0" target="_blank" rel="external">0.40.0</a></p></blockquote><p>最近把yoga源码看了一遍，它是一个按照<a href="https://www.w3.org/TR/css3-flexbox" target="_blank" rel="external">Flexbox</a>规范，<strong>利用Web熟悉的API做高效measure</strong>的库。本来想做个它在React Native for Android (以下简称RN4A)中的应用与分析，但是在这之前应该先将RN渲染流程搞懂，我们才能去进一步分析如何应用yoga去辅助测量。</p><a id="more"></a><h1 id="JSX的转码"><a href="#JSX的转码" class="headerlink" title="JSX的转码"></a><a name="jsx" href="#jsx">JSX的转码</a></h1><p>如果只是开发Web应用，都要给babel添加<a href="https://babeljs.io/docs/plugins/preset-react/" target="_blank" rel="external">React preset</a>，如果是开发RN，那么它都内置做好了，使用者体会不到。这个preset的作用，就是将JSX语法转化为纯js的代码。转码的结果可以参考<a href="https://facebook.github.io/react/docs/react-without-jsx.html" target="_blank" rel="external">React Without JSX</a>。</p><p>我拿了一个最普通的文件来做转码示例，原始的React代码如下：<a name="sample"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</div><div class="line">          Welcome to React Native!</div><div class="line">        &lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">AppRegistry.registerComponent(<span class="string">'Sample'</span>, () =&gt; Sample);</div></pre></td></tr></table></figure><p>转码后：（经过部分精简）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _react = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> _react2 = _interopRequireDefault(_react);</div><div class="line"><span class="keyword">var</span> _reactNative = <span class="built_in">require</span>(<span class="string">'react-native'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123;<span class="attr">default</span>: obj&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line">Sample = <span class="function"><span class="keyword">function</span> (<span class="params">_Component</span>) </span>&#123;</div><div class="line">  _createClass(Sample, [&#123;</div><div class="line">    key: <span class="string">'render'</span>, <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        _react2.default.createElement(_reactNative.View, &#123;<span class="attr">style</span>: styles.container&#125;,</div><div class="line">          _react2.default.createElement(_reactNative.Text, &#123;<span class="attr">style</span>: styles.welcome&#125;, <span class="string">'Welcome to React Native!'</span>)));</div><div class="line">    &#125;</div><div class="line">  &#125;]);</div><div class="line">  <span class="keyword">return</span> Sample;</div><div class="line">&#125;(_react.Component);</div><div class="line">_reactNative.AppRegistry.registerComponent(<span class="string">'Sample'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> Sample;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们可以看到，原先JSX的控件都被<a href="https://facebook.github.io/react/docs/react-api.html#createelement" target="_blank" rel="external">React.createElement</a>转化为<code>ReactElement</code>。在<code>ReactElement</code>中使用type字段存放原始对象（在此处就是<code>ReactNative.View</code>/<code>ReactNative.Text</code>），使用props存放childrens、其他传入属性等。</p><p><strong>JSX仅是一个语法糖</strong>，实际上它们最终都是<code>React.createElement</code>这样的<strong>原始写法</strong>。</p><h1 id="ReactNative的js启动流程"><a href="#ReactNative的js启动流程" class="headerlink" title="ReactNative的js启动流程"></a><a name="rn-start" href="#rn-start">ReactNative的js启动流程</a></h1><p>渲染是一个流程，它不会平白无故发生，总是有触发时机。第一次渲染在启动的时候，也是最容易把控到痕迹的时候，我们可以通过它去一步步剖析这个流程：</p><p><img src="/image/rn/rn-render-start.png" alt="rn-render-start"></p><p>首先，ReactNative的js代码都需要通过<code>AppRegistry.registerComponent</code>注册对应appkey的Component才能被启动。我们可以在<code>AppRegistry.js</code>中看到它注册了一个对应的回调，在Native启动过程中会通过jsbridge调用<code>AppRegistry.runApplication</code>启动js渲染流程，在js中会调用对应runnable，即后面的<code>renderApplication</code>。(关于RN4A启动流程与jsBridge初始化可以参考：<a href="https://zhuanlan.zhihu.com/p/20807406?refer=magilu" target="_blank" rel="external">【ReactNative For Android】框架启动核心路径剖析</a>与<a href="http://blog.desmondyao.com/rn-bridge/">【React Native for Android】jsBridge实现原理</a>)</p><p>在<code>renderApplication</code>时会将传入的Component变成<code>ReactElement</code>，包裹在<code>AppContainer</code>中，这个<code>AppContainer</code>主要用于外面包围一些Debug用的工具（如红盒）。在这之后如上述流程图中一步步走了下去，没什么其他分支，走到<code>ReactNativeMount</code>中就会有料出现了，我们来看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReactNativeMount.js</span></div><div class="line"></div><div class="line">renderComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  nextElement: ReactElement&lt;*&gt;,</span></span></div><div class="line"><span class="function"><span class="params">  containerTag: number,</span></span></div><div class="line"><span class="function"><span class="params">  callback?: ?((</span>) =&gt; <span class="title">void</span>)</span></div><div class="line"><span class="function">): ?<span class="title">ReactComponent</span>&lt;<span class="title">any</span>, <span class="title">any</span>, <span class="title">any</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">// 将Element使用相同顶层Wrapper包裹，render方法返回child（即nextElement)</span></div><div class="line">  <span class="keyword">var</span> nextWrappedElement = React.createElement(</div><div class="line">    TopLevelWrapper,</div><div class="line">    &#123; <span class="attr">child</span>: nextElement &#125;</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="comment">// 检查之前是否有节点已mount到目标节点上，若有则进行比较处理</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> instance = instantiateReactComponent(nextWrappedElement, <span class="literal">false</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 将mount任务提交入回调Queue</span></div><div class="line">  ReactUpdates.batchedUpdates(</div><div class="line">    batchedMountComponentIntoNode,</div><div class="line">    instance,</div><div class="line">    containerTag</div><div class="line">  );</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">return</span> component;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里将传入的Element都用<code>TopLevelWrapper</code>进行封装，但是它直接透传目标给<code>render</code>函数，可以暂时忽略这层。这里通过<code>instantiateReactComponent</code>生成了一个渲染对象实例，将<code>batchedMountComponentIntoNode()</code>方法提交入回调Queue，它里面最终会走到<code>ReactReconciler.mountComponent</code>里面，直接调用<code>instance.mountComponent</code>。</p><p>接下来就有两处关键地方要理解了：</p><ol><li><code>instantiateReactComponent</code>利用输入的<code>ReactElement</code>生成了什么东西？</li><li>利用<code>instance.mountComponent</code>怎么进行渲染？</li></ol><h1 id="如何生成React组件？"><a href="#如何生成React组件？" class="headerlink" title="如何生成React组件？"></a><a name="instantiate" href="#instantiate">如何生成React组件？</a></h1><p>先解释一下<code>instantiateReactComponent</code>的作用。</p><p>从一定角度上来说，React的组件可以分为两种：</p><ul><li><strong>元组件</strong> 框架内置的，可以直接用的组件。在RN上可以理解为就是<code>View</code>/<code>Image</code>这种。不同平台有<strong>不同的元组件实现</strong>，在Web上的组件实现可以参考<a href="https://github.com/lanjingling0510/blog/issues/1" target="_blank" rel="external">深入理解react（源码分析）</a>，在RN上见后续分析<a href="#rn-component">ReactNative的组件</a>。</li><li><strong>复合组件</strong> 用户封装之后的组件，一般可以通过<code>React.createClass</code>来构建，提供<code>render()</code>方法返回渲染目标（ES6中可以继承<code>React.Component</code>)。</li></ul><p>在React核心库中提供了<code>instantiateReactComponent.js</code>，供渲染平台调用。它在碰见<code>ReactElement</code>时会根据其中的type生成<strong>元组件</strong>或者<strong>复合组件</strong>，逻辑如下：</p><p><img src="/image/rn/rn-render-instantiate.png" alt="rn-render-instantiate"></p><p>在React早先的一个版本中，将代码拆分为React与ReactDOM（见<a href="https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#two-packages-react-and-react-dom" target="_blank" rel="external">Two Packages: React and React DOM</a>）。核心的React包中包含了基础的createElement/createClass/生命周期等React相关、渲染平台无关的代码。其中<strong>绿色的部分</strong>是React核心库提供的，<strong>蓝色部分</strong>是需要渲染平台提供的。</p><p><code>instantiateReactComponent</code>中依次判断了如下流程：</p><ol><li>当<strong>对象的type</strong>如果是string或function（至于为何是function，后面<a href="#rn-component">ReactNative的元组件</a>中有解释）时走第一层逻辑。当type为string时，渲染平台可以通过<code>ReactHostComponent.injectGenericComponentClass</code>这个API来注入生成组件逻辑，ReactDOM注入了这层处理，生成<code>ReactDOMComponent</code>，而RN不处理。若type函数的原型链中具有<strong>元组件API</strong>时，则new一个type实例；否则就生成一个<code>ReactCompositeComponent</code>（即复合组件）;</li><li>当对象为string时（此种情况对应直接写string，而不是用jsx包裹起来的语法），也交由渲染平台处理，可以通过<code>ReactHostComponent.injectTextComponentClass</code>来注入组件生成逻辑；</li><li>以上都不符合，则报错。</li></ol><p>判断函数对象是否<strong>元组件</strong>，它的原型链中需要提供以下两个API：</p><ul><li><code>mountComponent</code> 在首次渲染组件时调用；</li><li><code>receiveComponent</code> 更新组件内容、属性时调用；</li></ul><p>在<code>ReactCompositeComponent</code>中也包含有这两个API供调用，如在<code>mountComponent</code>时：</p><p><img src="/image/rn/rn-render-composite.jpeg" alt="rn-render-composite"></p><p>它会获取<code>render()</code>方法返回的渲染节点，并对它继续走<code>instantiate</code>/<code>mountComponent</code>的流程。如果<code>render()</code>返回的节点还是自定义的复合组件，那这个流程还会向下走，也即：<strong>mount流程会递归向下调用直到最后一个元组件</strong>。</p><h1 id="ReactNative的元组件"><a href="#ReactNative的元组件" class="headerlink" title="ReactNative的元组件"></a><a name="rn-component" href="#rn-component">ReactNative的元组件</a></h1><p>我们可以拿任意一个UI控件来入手看，就拿最简单的<code>View</code>来看一下，它的代码在Libraries/Components/View/View.js下，其实是一个复合组件，但是它的<code>render</code>方法返回的是一个元组件，看一下相关代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// View.js</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> View = React.createClass(&#123;</div><div class="line">  <span class="comment">// 属性声明...</span></div><div class="line"></div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">RCTView</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></div><div class="line"><span class="xml">  &#125;,</span></div><div class="line"><span class="xml">&#125;);</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">const RCTView = requireNativeComponent('RCTView', View, &#123;</span></div><div class="line"><span class="xml">  nativeOnly: &#123;</span></div><div class="line"><span class="xml">    nativeBackgroundAndroid: true,</span></div><div class="line"><span class="xml">    nativeForegroundAndroid: true,</span></div><div class="line"><span class="xml">  &#125;</span></div><div class="line"><span class="xml">&#125;);</span></div></pre></td></tr></table></figure><p>那这个<code>requireNativeComponent</code>做的什么呢？紧接着来看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// requireNativeComponent.js</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">requireNativeComponent</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  viewName: string,</span></span></div><div class="line"><span class="function"><span class="params">  componentInterface?: ?ComponentInterface,</span></span></div><div class="line"><span class="function"><span class="params">  extraConfig?: ?&#123;nativeOnly?: Object&#125;,</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> viewConfig = UIManager[viewName]; <span class="comment">// 由Native传入的对应ViewModule配置</span></div><div class="line">  viewConfig.uiViewClassName = viewName; </div><div class="line">  viewConfig.validAttributes = &#123;&#125;;</div><div class="line">  viewConfig.propTypes = componentInterface &amp;&amp; componentInterface.propTypes;</div><div class="line">  <span class="comment">// 所有React视图控件的prop都继承View的prop</span></div><div class="line">  <span class="keyword">const</span> nativeProps = &#123;</div><div class="line">    ...UIManager.RCTView.NativeProps,</div><div class="line">    ...viewConfig.NativeProps,</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> createReactNativeComponentClass(viewConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>createReactNativeComponentClass.js</code>中，我们可以看到它是返回了一个构造<code>ReactNativeBaseComponent</code>的<strong>构造函数</strong>。这下知道了为什么上面<code>instantiateReactComponent</code>里面使用的是“type是否为函数”的判断了吧。如果type为函数，并且原型链中含有元组件API，它就会用new一个这个函数实例。</p><p><code>ReactNativeBaseComponent</code>会在<code>mountComponent</code>/<code>receiveComponent</code>时对自己的child进行递归调用，以mount为例：</p><p><img src="/image/rn/rn-render-rnbase.jpeg" alt="rn-render-rnbase"></p><p>其中<code>ReactMultiChild</code>负责对节点的children进行递归调用、instantiate/mount，<code>UIManager</code>负责所有生成Native组件的操作。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个过程就是这样，RN将代码由JSX转化为JS组件，启动过程中利用<code>instantiateReactComponent</code>将ReactElement转化为复合组件<code>ReactCompositeComponent</code>与元组件<code>ReactNativeBaseComponent</code>，利用<code>ReactReconciler</code>对他们进行渲染。</p><p>下一篇中会讲述ReactNative如何利用UIManager组建Native的视图结构，敬请期待。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Android/" rel="tag"># Android</a> <a href="/tags/React-Native/" rel="tag"># React Native</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/super-activity-test/" rel="next" title="分享一个对所有Activity做单元测试的思路"><i class="fa fa-chevron-left"></i> 分享一个对所有Activity做单元测试的思路</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/rn-crash/" rel="prev" title="React Native for Android 异常处理概览">React Native for Android 异常处理概览 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Desmond Yao</p><p class="site-description motion-element" itemprop="description">Android developer.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/desmond1121" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://weibo.com/u/1901104743" target="_blank" title="Weibo"><i class="fa fa-fw fa-globe"></i>Weibo</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://kaedea.com/" title="Kaedea" target="_blank">Kaedea</a></li><li class="links-of-blogroll-item"><a href="http://yrom.net/" title="Yrom" target="_blank">Yrom</a></li><li class="links-of-blogroll-item"><a href="http://blog.zhaiyifan.cn/" title="MarkZhai" target="_blank">MarkZhai</a></li><li class="links-of-blogroll-item"><a href="http://abner-nimengbo.cn/" title="泥阿布" target="_blank">泥阿布</a></li><li class="links-of-blogroll-item"><a href="https://xiequan.info" title="谢权" target="_blank">谢权</a></li><li class="links-of-blogroll-item"><a href="http://rarnu.com/" title="何老师" target="_blank">何老师</a></li><li class="links-of-blogroll-item"><a href="http://fucknmb.com/" title="区长" target="_blank">区长</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JSX的转码"><span class="nav-number">1.</span> <span class="nav-text">JSX的转码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReactNative的js启动流程"><span class="nav-number">2.</span> <span class="nav-text">ReactNative的js启动流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何生成React组件？"><span class="nav-number">3.</span> <span class="nav-text">如何生成React组件？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReactNative的元组件"><span class="nav-number">4.</span> <span class="nav-text">ReactNative的元组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Desmond Yao</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script></body></html>